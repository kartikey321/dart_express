Project Overview
===============

Project Statistics:
Total Files: 23
Total Size: 74.97 KB

File Types:
  .md: 13 files
  .dart: 5 files
  .yaml: 4 files
  no extension: 1 files

Detected Technologies:

Folder Structure (Tree)
=====================
Legend: ✓ = Included in output, ✗ = Excluded from output

├── .gitignore (475 B) ✓
├── README.md (310 B) ✓
├── analysis_options.yaml (1.43 KB) ✓
├── content/
│   ├── _data/
│   │   ├── links.yaml (121 B) ✓
│   │   └── site.yaml (268 B) ✓
│   ├── about.md (4.27 KB) ✓
│   ├── advanced/
│   │   └── isolated-containers.md (7.79 KB) ✓
│   ├── api/
│   ├── core-concepts/
│   │   ├── error-handling.md (7.95 KB) ✓
│   │   ├── middleware.md (5.05 KB) ✓
│   │   ├── routing.md (3.35 KB) ✓
│   │   └── sessions.md (7.95 KB) ✓
│   ├── deployment/
│   │   └── docker.md (5.96 KB) ✓
│   ├── examples/
│   │   └── todo-api.md (5.58 KB) ✓
│   ├── getting-started/
│   │   ├── installation.md (1.78 KB) ✓
│   │   └── quick-start.md (4.39 KB) ✓
│   ├── index.md (2.00 KB) ✓
│   └── security/
│       └── cors.md (4.82 KB) ✓
├── lib/
│   ├── components/
│   │   └── clicker.dart (847 B) ✓
│   ├── main.client.dart (852 B) ✓
│   ├── main.client.options.dart (2.12 KB) ✓
│   ├── main.server.dart (4.76 KB) ✓
│   └── main.server.options.dart (2.67 KB) ✓
├── pubspec.yaml (322 B) ✓

==============

File Name: .gitignore
Size: 475 B
Code:
# Files and directories created by pub.
**/doc/api/
.dart_tool/
.packages

# Conventional directory for build output.
/build/

# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

-------- [ Separator ] ------

File Name: README.md
Size: 310 B
Code:
# site

A documentation site built with Jaspr

## Running the project

Run your project using `jaspr serve`.

The development server will be available on `http://localhost:8080`.

## Building the project

Build your project using `jaspr build`.

The output will be located inside the `build/jaspr/` directory.

-------- [ Separator ] ------

File Name: analysis_options.yaml
Size: 1.43 KB
Code:
# This file configures the static analysis results for your project (errors,
# warnings, and lints).
#
# This enables the 'recommended' set of lints from `package:lints`.
# This set helps identify many issues that may lead to problems when running
# or consuming Dart code, and enforces writing Dart using a single, idiomatic
# style and format.
#
# If you want a smaller set of lints you can change this to specify
# 'package:lints/core.yaml'. These are just the most critical lints
# (the recommended set includes the core lints).
# The core lints are also what is used by pub.dev for scoring packages.

include: package:lints/recommended.yaml

analyzer:
#   exclude:
#     - path/to/excluded/files/**

# Jaspr has a custom analyzer plugin 'jaspr_lints', which is enabled here.
#
# You can toggle Jaspr specific lint rules in the 'diagnostics' section below.
plugins:
  jaspr_lints:
    version: ^0.6.0
    diagnostics:
      prefer_html_components: true
      sort_children_last: true
      styles_ordering: true

# Uncomment the following section to enable or disable additional rules.

# linter:
#   rules:
#     camel_case_types: true

# For more information about the core and recommended set of lints, see
# https://dart.dev/go/core-lints

formatter:
  # Change this to your preferred line length.
  page_width: 120
  trailing_commas: preserve

# For additional information about configuring this file, see
# https://dart.dev/guides/language/analysis-options

-------- [ Separator ] ------

File Name: content/_data/links.yaml
Size: 121 B
Code:
website: https://jaspr.site
docs: https://docs.jaspr.site/content
quickstart: https://docs.jaspr.site/content/quick_start
-------- [ Separator ] ------

File Name: content/_data/site.yaml
Size: 268 B
Code:
# Site Configuration
titleBase: DOCS
favicon: favicon.ico

# Social media links
social:
  - name: Github
    url: https://github.com/schultek
  - name: X/Twitter
    url: https://twitter.com/schultek_dev
  - name: Bluesky
    url: https://bsky.app/profile/schultek.dev
-------- [ Separator ] ------

File Name: content/about.md
Size: 4.27 KB
Code:
# About dart_express

dart_express is a web framework for Dart inspired by Express.js, designed to make building HTTP servers simple, intuitive, and productive.

## Philosophy

### Simplicity First
dart_express follows the Express.js philosophy: provide a minimal, flexible framework that doesn't get in your way.

```dart
final app = DartExpress();
app.get('/', (req, res) => res.text('Simple!'));
await app.listen(3000);
```

### Middleware-Centric
Everything is a middleware. This makes the framework incredibly composable:

```dart
// Logging
app.use((req, res, next) async {
  print('${req.method} ${req.uri.path}');
  await next();
});

// CORS
app.use(app.cors());

// Routes
app.get('/api', handler);
```

### Type-Safe
Built on Dart, you get compile-time type safety:

```dart
app.post('/api/user', (req, res) async {
  final body = await req.body; // Map<String, dynamic>
  final name = body['name'] as String; // Type-checked
  res.json({'created': name});
});
```

## Architecture

### Request Pipeline

```
Request →  Middleware 1 →  Middleware 2 →  Route Handler →  Response
              ↓                ↓                ↓
           next()          next()           res.json()
```

Every request flows through:
1. **Global middleware** (CORS, logging, etc.)
2. **Route-specific middleware**
3. **Route handler**
4. **Response**

### Core Components

#### **DartExpress**
The main application class. Manages middleware, routing, and server lifecycle.

#### **Request**
Represents an HTTP request with helpers for:
- Path parameters: `req.params['id']`
- Query strings: `req.query['search']`
- Body parsing: `await req.body`
- Sessions: `req.session`
- Headers: `req.headers`

#### **Response**
Fluent API for building responses:
- `res.text('Hello')`
- `res.json({...})`
- `res.status(404)`
- `res.cookie('name', 'value')`

#### **Router**
Radix-tree based router for fast path matching with support for:
- Path parameters: `/users/:id`
- Wildcards: `/files/*`
- Method-based routing

## Key Features

### Sessions
Built-in session management with pluggable stores:

```dart
final app = DartExpress(
  sessionSecret: 'your-secret-key',
  sessionStore: MemorySessionStore(), // Default
);

app.get('/counter', (req, res) {
  final count = (req.session['count'] as int? ?? 0) + 1;
  req.session['count'] = count;
  res.json({'visits': count});
});
```

### CORS
One-line CORS configuration:

```dart
app.use(app.cors(
  allowedOrigins: ['https://example.com'],
  allowedMethods: ['GET', 'POST'],
  credentials: true,
));
```

### Rate Limiting
Protect your API from abuse:

```dart
app.use(app.rateLimit(
  maxRequests: 100,
  windowMs: 60000, // 1 minute
));
```

### Dependency Injection
Uses GetIt for service management:

```dart
final container = GetIt.instance;
container.registerSingleton(UserService());

app.get('/users', (req, res) {
  final userService = container<UserService>();
  res.json(userService.getAll());
});
```

## Performance

dart_express is designed for performance:

- **Radix Tree Router**: O(log n) route matching
- **Zero-copy Body Parsing**: Efficient request handling  
- **Async/Await**: Non-blocking I/O throughout
- **Isolate Support**: Scale across CPU cores

Run benchmarks:
```bash
cd packages/dart_express/benchmark
dart run bin/run_benchmarks.dart
```

## Comparison

| Feature | dart_express | Shelf | Aqueduct |
|---------|-------------|-------|----------|
| Express-like API | ✅ | ❌ | ❌ |
| Built-in Sessions | ✅ | ❌ | ✅ |
| Middleware Pipeline | ✅ | ✅ | ✅ |
| DI Container | ✅ (GetIt) | ❌ | ✅ |
| Active Development | ✅ | ✅ | ❌ (Discontinued) |

## Examples

Check out these complete examples:

- **TODO API** - Full REST API at `/apps/dart_express_examples/todo_api_example`
- **Session Auth** - Authentication demo at `/apps/dart_express_examples/session_security_example`
- **MongoDB** - Database integration at `/apps/dart_express_examples/mongo_example`

## Contributing

We welcome contributions! Check out our [GitHub repository](https://github.com/kartikey321/dart_express) to:

- Report bugs
- Suggest features
- Submit pull requests
- Improve documentation

## License

dart_express is open source software licensed under the MIT license.

---

Ready to build something? Check out the [GitHub repo](https://github.com/kartikey321/dart_express) to get started!

-------- [ Separator ] ------

File Name: content/advanced/isolated-containers.md
Size: 7.79 KB
Code:
# Isolated Containers

Isolated containers allow you to modularize your application by creating self-contained services with their own routing, middleware, and dependency injection scopes.

## Overview

`IsolatedContainer` provides:
- **Prefix-based routing** - Mount under specific path prefixes
- **Isolated dependencies** - Separate DI container per service
- **Middleware isolation** - Independent middleware pipeline  
- **Shared sessions** - Coordinates with parent app
- **Modular architecture** - Organize large apps into services

## Basic Usage

Create and mount an isolated container:

```dart
import 'package:dart_express/dart_express.dart';

void main() async {
  final app = DartExpress();
  
  // Create isolated container for admin routes
  final admin = IsolatedContainer(prefix: '/admin');
  
  admin.get('/', (req, res) {
    res.text('Admin Dashboard');
  });
  
  admin.get('/users', (req, res) {
    res.json({'users': []});
  });
  
  // Mount the container
  admin.mount(app);
  
  // Main app routes
  app.get('/', (req, res) {
    res.text('Homepage');
  });
  
  await app.listen(3000);
}
```

Access routes:
- `/` → Homepage (main app)
- `/admin` → Admin Dashboard (isolated)
- `/admin/users` → Users list (isolated)

## Use Cases

### 1. API Versioning

Separate API versions with different dependencies:

```dart
void main() async {
  final app = DartExpress();
  
  // API v1
  final v1 = IsolatedContainer(prefix: '/api/v1');
  v1.container.registerSingleton(UserServiceV1());
  
  v1.get('/users', (req, res) {
    final service = req.container<UserServiceV1>();
    res.json(service.getAll());
  });
  
  v1.mount(app);
  
  // API v2 with new service implementation
  final v2 = IsolatedContainer(prefix: '/api/v2');
  v2.container.registerSingleton(UserServiceV2());
  
  v2.get('/users', (req, res) {
    final service = req.container<UserServiceV2>();
    res.json(service.getAllPaginated());
  });
  
  v2.mount(app);
  
  await app.listen(3000);
}
```

### 2. Microservices Architecture

Organize app into logical services:

```dart
void main() async {
  final app = DartExpress();
  
  // Auth service
  final auth = IsolatedContainer(prefix: '/auth');
  auth.post('/login', loginHandler);
  auth.post('/logout', logoutHandler);
  auth.mount(app);
  
  // User service
  final users =  IsolatedContainer(prefix: '/users');
  users.get('/', getAllUsers);
  users.get('/:id', getUser);
  users.mount(app);
  
  // Payment service
  final payments = IsolatedContainer(prefix: '/payments');
  payments.post('/charge', chargeHandler);
  payments.get('/history', historyHandler);
  payments.mount(app);
  
  await app.listen(3000);
}
```

### 3. Multi-Tenant Applications

Isolate tenant-specific logic:

```dart
void main() async {
  final app = DartExpress();
  
  // Tenant A
  final tenantA = IsolatedContainer(prefix: '/tenant-a');
  tenantA.container.registerSingleton(DatabaseA());
  tenantA.get('/data', (req, res) {
    final db = req.container<DatabaseA>();
    res.json(db.query());
  });
  tenantA.mount(app);
  
  // Tenant B
  final tenantB = IsolatedContainer(prefix: '/tenant-b');
  tenantB.container.registerSingleton(DatabaseB());
  tenantB.get('/data', (req, res) {
    final db = req.container<DatabaseB>();
    res.json(db.query());
  });
  tenantB.mount(app);
  
  await app.listen(3000);
}
```

## Dependency Injection

Each container has its own DI scope:

```dart
class AdminService {
  List<String> getAdmins() => ['admin1', 'admin2'];
}

class UserService {
  List<String> getUsers() => ['user1', 'user2'];
}

void main() async {
  final app = DartExpress();
  app.container.registerSingleton(UserService());
  
  final admin = IsolatedContainer(prefix: '/admin');
  admin.container.registerSingleton(AdminService());
  
  admin.get('/list', (req, res) {
    // Access isolated container's service
    final adminService = req.container<AdminService>();
    
    // Can also access parent container if needed
    // But isolated container takes precedence
    res.json({'admins': adminService.getAdmins()});
  });
  
  admin.mount(app);
  
  await app.listen(3000);
}
```

## Middleware Isolation

Container middleware only applies to its routes:

```dart
void main() async {
  final app = DartExpress();
  
  // Global middleware
  app.use((req, res, next) async {
    print('Global: ${req.uri.path}');
    await next();
  });
  
  // Admin container with auth middleware
  final admin = IsolatedContainer(prefix: '/admin');
  
  admin.use((req, res, next) async {
    // This only runs for /admin/* routes
    if (req.session['role'] != 'admin') {
      return res.status(403).json({'error': 'Admin only'});
    }
    await next();
  });
  
  admin.get('/dashboard', (req, res) {
    res.text('Admin Dashboard');
  });
  
  admin.mount(app);
  
  await app.listen(3000);
}
```

## Session Sharing

Sessions are shared between parent and isolated containers:

```dart
void main() async {
  final app = DartExpress(
    sessionSecret: 'secret',
  );
  
  app.post('/login', (req, res) async {
    req.session['userId'] = '123';
    req.session['role'] = 'admin';
    res.json({'success': true});
  });
  
  final admin = IsolatedContainer(prefix: '/admin');
  
  admin.get('/profile', (req, res) {
    // Access session from parent request
    final userId = req.session['userId'];
    final role = req.session['role'];
    
    res.json({
      'userId': userId,
      'role': role,
    });
  });
  
  admin.mount(app);
  
  await app.listen(3000);
}
```

## Path Resolution

Paths are resolved relative to the container prefix:

```dart
final api = IsolatedContainer(prefix: '/api');

// These are equivalent:
api.get('/users', handler);    // Mounted at /api/users
api.get('users', handler);     // Also mounted at /api/users

// Root of container
api.get('/', handler);         // Mounted at /api
```

## Standalone Mode

Run container as independent service:

```dart
void main() async {
  final service = IsolatedContainer(prefix: '');
  
  service.get('/', (req, res) {
    res.text('Standalone Service');
  });
  
  service.get('/health', (req, res) {
    res.json({'status': 'ok'});
  });
  
  // Listen on its own port
  await service.listen(8080);
  print('Service running on port 8080');
}
```

## Advanced Patterns

### Plugin System

Create reusable service modules:

```dart
class BlogPlugin {
  IsolatedContainer create() {
    final blog = IsolatedContainer(prefix: '/blog');
    
    blog.get('/', getAllPosts);
    blog.get('/:id', getPost);
    blog.post('/', createPost);
    
    blog.container.registerSingleton(BlogService());
    
    return blog;
  }
}

void main() async {
  final app = DartExpress();
  
  // Mount blog plugin
  final blog = BlogPlugin().create();
  blog.mount(app);
  
  await app.listen(3000);
}
```

### Nested Containers

Mount containers within containers:

```dart
void main() async {
  final app = DartExpress();
  
  final api = IsolatedContainer(prefix: '/api');
  
  final v1 = IsolatedContainer(prefix: '/v1');
  v1.get('/users', handler);
  v1.mount(api);  // Mounted at /api/v1/users
  
  api.mount(app);
  
  await app.listen(3000);
}
```

## Best Practices

1. **Use meaningful prefixes** - `/api/v1`, `/admin`, `/tenant-123`
2. **Isolate dependencies** - Register services specific to each container
3. **Share global state** - Use parent container for shared services
4. **Document boundaries** - Clearly define which routes belong where
5. **Test isolation** - Unit test containers independently

## Performance

Isolated containers have minimal overhead:
- Routes matched by parent router first
- Delegation only when prefix matches
- Shared response object (no duplication)
- Same performance as regular routes

## Next Steps

- [Middleware](/core-concepts/middleware) - Add container-specific middleware
- [Dependency Injection](/guides/dependency-injection) - Advanced DI patterns
- [Testing](/guides/testing) - Test isolated containers

-------- [ Separator ] ------

File Name: content/core-concepts/error-handling.md
Size: 7.95 KB
Code:
# Error Handling

Handle errors gracefully and provide meaningful feedback to clients.

## Basic Error Handling

### Try-Catch in Routes

```dart
app.get('/user/:id', (req, res) async {
  try {
    final userId = req.params['id']!;
    final user = await database.getUser(userId);
    
    if (user == null) {
      return res.status(404).json({'error': 'User not found'});
    }
    
    res.json(user);
  } catch (e) {
    res.status(500).json({
      'error': 'Internal server error',
      'message': e.toString(),
    });
  }
});
```

## Global Error Handler

Catch all unhandled errors:

```dart
void main() async {
  final app = DartExpress();
  
  // Your routes
  app.get('/', myHandler);
  
  // Global error handler (must be last)
  app.use((req, res, next) async {
    try {
      await next();
    } catch (e, stackTrace) {
      print('Error: $e');
      print(stackTrace);
      
      res.status(500).json({
        'error': 'Internal server error',
        'message': e.toString(),
      });
    }
  });
  
  await app.listen(3000);
}
```

## Custom Error Classes

Create typed errors:

```dart
class AppError implements Exception {
  final int statusCode;
  final String message;
  final Map<String, dynamic>? details;
  
  AppError(this.message, {this.statusCode = 500, this.details});
  
  @override
  String toString() => message;
}

class NotFoundError extends AppError {
  NotFoundError(String message) : super(message, statusCode: 404);
}

class ValidationError extends AppError {
  ValidationError(String message, Map<String, dynamic> details)
      : super(message, statusCode: 400, details: details);
}

class UnauthorizedError extends AppError {
  UnauthorizedError(String message) : super(message, statusCode: 401);
}
```

### Using Custom Errors

```dart
app.get('/user/:id', (req, res) async {
  final user = await database.getUser(req.params['id']!);
  
  if (user == null) {
    throw NotFoundError('User not found');
  }
  
  res.json(user);
});

// Error handler
app.use((req, res, next) async {
  try {
    await next();
  } catch (e) {
    if (e is AppError) {
      return res.status(e.statusCode).json({
        'error': e.message,
        if (e.details != null) 'details': e.details,
      });
    }
    
    // Unknown error
    res.status(500).json({'error': 'Internal server error'});
  }
});
```

## Validation Errors

Handle invalid input:

```dart
app.post('/user', (req, res) async {
  final body = await req.body;
  final errors = <String, String>{};
  
  if (body['email'] == null || !isValidEmail(body['email'])) {
    errors['email'] = 'Valid email required';
  }
  
  if (body['password'] == null || body['password'].length < 8) {
    errors['password'] = 'Password must be at least 8 characters';
  }
  
  if (errors.isNotEmpty) {
    throw ValidationError('Validation failed', errors);
  }
  
  // Process request...
});
```

## Async Error Handling

Properly handle async errors:

```dart
app.get('/data', (req, res) async {
  try {
    final data = await fetchFromAPI();
    res.json(data);
  } on TimeoutException {
    res.status(504).json({'error': 'Gateway timeout'});
  } on SocketException {
    res.status(503).json({'error': 'Service unavailable'});
  } catch (e) {
    res.status(500).json({'error': 'Internal server error'});
  }
});
```

## Error Response Format

### Development vs Production

```dart
app.use((req, res, next) async {
  try {
    await next();
  } catch (e, stackTrace) {
    final isDev = Platform.environment['ENV'] != 'production';
    
    res.status(500).json({
      'error': 'Internal server error',
      if (isDev) 'message': e.toString(),
      if (isDev) 'stack': stackTrace.toString(),
    });
  }
});
```

### Structured Errors

```dart
class ErrorResponse {
  final String error;
  final int statusCode;
  final String? message;
  final Map<String, dynamic>? details;
  final String timestamp;
  
  ErrorResponse({
    required this.error,
    required this.statusCode,
    this.message,
    this.details,
  }) : timestamp = DateTime.now().toIso8601String();
  
  Map<String, dynamic> toJson() => {
    'error': error,
    'statusCode': statusCode,
    if (message != null) 'message': message,
    if (details != null) 'details': details,
    'timestamp': timestamp,
  };
}

// Usage
res.status(400).json(ErrorResponse(
  error: 'Bad Request',
  statusCode: 400,
  message: 'Invalid email format',
  details: {'field': 'email'},
).toJson());
```

## HTTP Status Codes

Use appropriate status codes:

```dart
// 400 - Bad Request
res.status(400).json({'error': 'Invalid input'});

// 401 - Unauthorized  
res.status(401).json({'error': 'Authentication required'});

// 403 - Forbidden
res.status(403).json({'error': 'Access denied'});

// 404 - Not Found
res.status(404).json({'error': 'Resource not found'});

// 409 - Conflict
res.status(409).json({'error': 'Email already exists'});

// 422 - Unprocessable Entity
res.status(422).json({'error': 'Validation failed', 'details': errors});

// 500 - Internal Server Error
res.status(500).json({'error': 'Internal server error'});

// 503 - Service Unavailable
res.status(503).json({'error': 'Service temporarily unavailable'});
```

## Database Errors

Handle database-specific errors:

```dart
app.post('/user', (req, res) async {
  try {
    final user = await database.createUser(data);
    res.status(201).json(user);
  } on DuplicateKeyException {
    res.status(409).json({'error': 'Email already exists'});
  } on DatabaseException catch (e) {
    print('Database error: $e');
    res.status(500).json({'error': 'Database error'});
  }
});
```

## Logging Errors

Log errors for debugging:

```dart
import 'package:logging/logging.dart';

final logger = Logger('MyApp');

app.use((req, res, next) async {
  try {
    await next();
  } catch (e, stackTrace) {
    logger.severe('Error processing request', e, stackTrace);
    
    res.status(500).json({
      'error': 'Internal server error',
      'requestId': generateRequestId(),
    });
  }
});
```

## Error Monitoring

Integrate with error tracking services:

```dart
app.use((req, res, next) async {
  try {
    await next();
  } catch (e, stackTrace) {
    // Send to Sentry, Bugsnag, etc.
    await errorTracker.captureException(e, stackTrace: stackTrace);
    
    res.status(500).json({'error': 'Internal server error'});
  }
});
```

## Rate Limit Errors

Handle rate limiting:

```dart
app.use(app.rateLimit(
  maxRequests: 100,
  windowMs: 60000,
  handler: (req, res) {
    res.status(429).json({
      'error': 'Too many requests',
      'retryAfter': 60,
    });
  },
));
```

## 404 Not Found

Handle routes that don't exist:

```dart
void main() async {
  final app = DartExpress();
  
  // Your routes
  app.get('/users', getUserHandler);
  app.post('/users', createUserHandler);
  
  // 404 handler (must be after all routes)
  app.use((req, res, next) async {
    res.status(404).json({
      'error': 'Not Found',
      'path': req.uri.path,
    });
  });
  
  await app.listen(3000);
}
```

## Best Practices

1. **Always use try-catch** for async operations
2. **Return appropriate status codes**
3. **Don't expose stack traces** in production
4. **Log errors** for debugging
5. **Use typed errors** for better error handling
6. **Test error scenarios**
7. **Document error responses** in API docs

## Testing Errors

```dart
import 'package:test/test.dart';
import 'package:http/http.dart' as http;

void main() {
  test('returns 404 for invalid route', () async {
    final response = await http.get(
      Uri.parse('http://localhost:3000/invalid'),
    );
    
    expect(response.statusCode, 404);
    expect(jsonDecode(response.body)['error'], 'Not Found');
  });
  
  test('returns 400 for invalid input', () async {
    final response = await http.post(
      Uri.parse('http://localhost:3000/user'),
      body: {'email': 'invalid'},
    );
    
    expect(response.statusCode, 400);
  });
}
```

## Next Steps

- [Middleware](/core-concepts/middleware) - Create error handling middleware
- [Sessions](/core-concepts/sessions) - Handle auth errors
- [Testing](/guides/testing) - Test error scenarios

-------- [ Separator ] ------

File Name: content/core-concepts/middleware.md
Size: 5.05 KB
Code:
# Middleware

Middleware functions are the building blocks of dart_express applications. They process requests, modify responses, and control the flow of execution.

## What is Middleware?

Middleware is a function that has access to the request object (`req`), response object (`res`), and the next middleware function (`next`).

```dart
Future<void> myMiddleware(Request req, Response res, NextFunction next) async {
  // Do something before the route handler
  print('Request received');
  
  // Pass control to the next middleware
  await next();
  
  // Do something after the route handler
  print('Response sent');
}
```

## Using Middleware

### Global Middleware

Applies to all routes:

```dart
final app = DartExpress();

// Logging middleware
app.use((req, res, next) async {
  print('[${DateTime.now()}] ${req.method} ${req.uri.path}');
  await next();
});

// Your routes
app.get('/', (req, res) => res.text('Hello!'));
```

### Route-Specific Middleware

Apply to specific routes:

```dart
Future<void> authMiddleware(Request req, Response res, NextFunction next) async {
  final token = req.headers['authorization'];
  
  if (token == null) {
    return res.status(401).json({'error': 'Unauthorized'});
  }
  
  // Verify token...
  await next();
}

app.get('/protected', authMiddleware, (req, res) {
  res.json({'message': 'Secret data'});
});
```

## Built-in Middleware

### CORS

Enable Cross-Origin Resource Sharing:

```dart
app.use(app.cors(
  allowedOrigins: ['https://example.com'],
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
));
```

### Rate Limiting

Protect against abuse:

```dart
app.use(app.rateLimit(
  maxRequests: 100,
  windowMs: 60000, // 1 minute
));
```

## Middleware Patterns

### Authentication

```dart
Future<void> requireAuth(Request req, Response res, NextFunction next) async {
  if (!req.session.containsKey('userId')) {
    return res.status(401).json({'error': 'Please log in'});
  }
  await next();
}

app.get('/profile', requireAuth, (req, res) {
  final userId = req.session['userId'];
  res.json({'userId': userId});
});
```

### Request Validation

```dart
Future<void> validateUser(Request req, Response res, NextFunction next) async {
  final body = await req.body;
  
  if (body['email'] == null || body['password'] == null) {
    return res.status(400).json({
      'error': 'Email and password required'
    });
  }
  
  await next();
}

app.post('/signup', validateUser, (req, res) async {
  final body = await req.body;
  // Create user...
});
```

### Error Handling

```dart
app.use((req, res, next) async {
  try {
    await next();
  } catch (e, stack) {
    print('Error: $e');
    print(stack);
    res.status(500).json({
      'error': 'Internal server error',
      'message': e.toString(),
    });
  }
});
```

### Request Timing

```dart
app.use((req, res, next) async {
  final start = DateTime.now();
  
  await next();
  
  final duration = DateTime.now().difference(start);
  print('${req.method} ${req.uri.path} - ${duration.inMilliseconds}ms');
});
```

## Middleware Order

Middleware executes in the order it's defined:

```dart
// 1. Logging
app.use((req, res, next) async {
  print('1: Before');
  await next();
  print('1: After');
});

// 2. Auth check
app.use((req, res, next) async {
  print('2: Before');
  await next();
  print('2: After');
});

// 3. Route handler
app.get('/', (req, res) {
  print('3: Handler');
  res.text('Hello!');
});
```

Output:
```
1: Before
2: Before
3: Handler
2: After  
1: After
```

## Stopping the Chain

Don't call `next()` to stop:

```dart
app.use((req, res, next) async {
  if (req.headers['api-key'] != 'secret') {
    return res.status(403).json({'error': 'Forbidden'});
    // next() NOT called - stops here
  }
  await next();
});
```

## Modifying Request/Response

Middleware can modify the request/response objects:

```dart
app.use((req, res, next) async {
  // Add custom data to request
  req.session['timestamp'] = DateTime.now().toIso8601String();
  
  // Add custom headers to response
  res.setHeader('X-Powered-By', 'dart_express');
  
  await next();
});
```

## Third-Party Middleware

Create reusable middleware packages:

```dart
// my_logger_middleware.dart
Future<void> loggerMiddleware({
  bool showTimestamp = true,
}) {
  return (Request req, Response res, NextFunction next) async {
    final time = showTimestamp ? '[${DateTime.now()}] ' : '';
    print('$time${req.method} ${req.uri.path}');
    await next();
  };
}

// Usage
app.use(loggerMiddleware(showTimestamp: true));
```

## Best Practices

1. **Keep middleware focused** - Each middleware should do one thing well
2. **Always call next()** - Unless you're terminating the request
3. **Error handling** - Wrap route handlers in try-catch middleware
4. **Order matters** - Put logging first, error handling last
5. **Async/await** - Always use async and await next()

## Next Steps

- [Error Handling](/core-concepts/error-handling) - Handle errors gracefully
- [Sessions](/core-concepts/sessions) - Manage user sessions
- [Security](/security/cors) - Secure your application

-------- [ Separator ] ------

File Name: content/core-concepts/routing.md
Size: 3.35 KB
Code:
# Routing

dart_express uses a fast radix-tree router to match incoming requests to handlers.

## Basic Routes

Define routes for different HTTP methods:

```dart
final app = DartExpress();

app.get('/users', (req, res) {
  res.json({'users': []});
});

app.post('/users', (req, res) async {
  final body = await req.body;
  res.status(201).json(body);
});

app.put('/users/:id', (req, res) {
  res.json({'updated': req.params['id']});
});

app.delete('/users/:id', (req, res) {
  res.status(204).send();
});
```

## Path Parameters

Capture dynamic segments from the URL:

```dart
app.get('/users/:userId/posts/:postId', (req, res) {
  final userId = req.params['userId'];
  final postId = req.params['postId'];
  
  res.json({
    'userId': userId,
    'postId': postId,
  });
});
```

Access via: `/users/123/posts/456`

## Query Parameters

Access query string parameters:

```dart
app.get('/search', (req, res) {
  final query = req.query['q'];
  final page = int.tryParse(req.query['page'] ?? '1') ?? 1;
  
  res.json({
    'query': query,
    'page': page,
    'results': [],
  });
});
```

Access via: `/search?q=dart&page=2`

## Wildcard Routes

Match multiple path segments:

```dart
app.get('/files/*', (req, res) {
  final filePath = req.params['*'];
  res.text('File path: $filePath');
});
```

Access `/files/documents/report.pdf` → captures `documents/report.pdf`

## Route Groups

Organize routes with common prefixes:

```dart
// API v1 routes
app.get('/api/v1/users', getUsersV1);
app.get('/api/v1/posts', getPostsV1);

// API v2 routes
app.get('/api/v2/users', getUsersV2);
app.get('/api/v2/posts', getPostsV2);
```

## Route Order

Routes are matched in the order they're defined:

```dart
// Specific route first
app.get('/users/me', (req, res) {
  res.json({'user': 'current user'});
});

// Generic route second
app.get('/users/:id', (req, res) {
  res.json({'user': req.params['id']});
});
```

## Controllers

Organize related routes in controllers:

```dart
class UserController {
  void getAll(Request req, Response res) {
    res.json({'users': []});
  }
  
  void getById(Request req, Response res) {
    res.json({'id': req.params['id']});
  }
  
  Future<void> create(Request req, Response res) async {
    final body = await req.body;
    res.status(201).json(body);
  }
}

void main() {
  final app = DartExpress();
  final users = UserController();
  
  app.get('/users', users.getAll);
  app.get('/users/:id', users.getById);
  app.post('/users', users.create);
}
```

## Method Chaining

Chain multiple route handlers:

```dart
app
  .get('/users', getAllUsers)
  .post('/users', createUser)
  .put('/users/:id', updateUser)
  .delete('/users/:id', deleteUser);
```

## All Methods

Handle any HTTP method:

```dart
app.all('/api/*', (req, res, next) async {
  print('API called: ${req.method} ${req.uri.path}');
  await next();
});
```

## Regular Expressions

For complex patterns, routes use glob syntax internally:

```dart
app.get('/users/:id', handler);        // :id matches any segment
app.get('/files/*', handler);          // * matches multiple segments
```

## Performance

The radix tree router provides:
- **O(log n) lookup time**
- **Efficient matching** even with thousands of routes
- **Zero allocations** for route matching

## Next Steps

- [Middleware](/core-concepts/middleware) - Add functionality to routes
- [Request & Response](/api/request-response) - API reference

-------- [ Separator ] ------

File Name: content/core-concepts/sessions.md
Size: 7.95 KB
Code:
# Sessions

dart_express provides built-in session management with pluggable storage backends.

## Quick Start

Enable sessions with a secret key:

```dart
final app = DartExpress(
  sessionSecret: 'your-secret-key-min-32-characters-long!',
);

app.get('/counter', (req, res) {
  final count = (req.session['count'] as int? ?? 0) + 1;
  req.session['count'] = count;
  res.json({'visits': count});
});

await app.listen(3000);
```

## How Sessions Work

1. **First Request**: Client has no session cookie
2. **Server Creates Session**: Generates session ID and stores data
3. **Send Cookie**: Server sends signed session cookie to client
4. **Subsequent Requests**: Client sends cookie, server loads session

## Accessing Sessions

### Reading Data

```dart
app.get('/profile', (req, res) {
  final userId = req.session['userId'];
  final username = req.session['username'];
  
  if (userId == null) {
    return res.status(401).json({'error': 'Not logged in'});
  }
  
  res.json({
    'userId': userId,
    'username': username,
  });
});
```

### Writing Data

```dart
app.post('/login', (req, res) async {
  final body = await req.body;
  
  // Verify credentials...
  
  // Store in session
  req.session['userId'] = '123';
  req.session['username'] = body['username'];
  req.session['loginTime'] = DateTime.now().toIso8601String();
  
  res.json({'success': true});
});
```

### Deleting Data

```dart
app.post('/logout', (req, res) {
  req.session.clear();
  res.json({'message': 'Logged out'});
});
```

## Session Stores

### Memory Store (Default)

Good for development, not for production:

```dart
final app = DartExpress(
  sessionSecret: 'secret',
  sessionStore: MemorySessionStore(), // Default
);
```

**Limitations:**
- Data lost on server restart
- Doesn't work with multiple server instances
- Memory usage grows over time

### Custom Store

Implement `SessionStore` for your backend:

```dart
class RedisSessionStore implements SessionStore {
  final RedisClient redis;
  
  RedisSessionStore(this.redis);
  
  @override
  Future<Map<String, dynamic>?> get(String sessionId) async {
    final data = await redis.get('session:$sessionId');
    return data != null ? jsonDecode(data) : null;
  }
  
  @override
  Future<void> set(String sessionId, Map<String, dynamic> data, {Duration? ttl}) async {
    await redis.set(
      'session:$sessionId',
      jsonEncode(data),
      ex: ttl?.inSeconds ?? 86400, // 24 hours default
    );
  }
  
  @override
  Future<void> destroy(String sessionId) async {
    await redis.del('session:$sessionId');
  }
  
  @override
  Future<void> dispose() async {
    await redis.close();
  }
}

// Usage
final app = DartExpress(
  sessionSecret: 'secret',
  sessionStore: RedisSessionStore(redisClient),
);
```

## Session Configuration

### Session Secret

**Required** - Used to sign session cookies:

```dart
final app = DartExpress(
  sessionSecret: Platform.environment['SESSION_SECRET']!,
);
```

Requirements:
- Minimum 32 characters
- Cryptographically random
- Never commit to git
- Rotate periodically

### Secure Cookies

Enable for HTTPS (production):

```dart
final app = DartExpress(
  sessionSecret: 'secret',
  secureCookies: true, // HTTPS only
);
```

### Cookie Name

Customize the session cookie name:

```dart
final app = DartExpress(
  sessionSecret: 'secret',
  sessionCookieName: 'my_app_session',
);
```

## Authentication Example

Complete login/logout flow:

```dart
void main() async {
  final app = DartExpress(
    sessionSecret: Platform.environment['SESSION_SECRET']!,
    secureCookies: true,
  );
  
  // Login endpoint
  app.post('/login', (req, res) async {
    final body = await req.body;
    final email = body['email'];
    final password = body['password'];
    
    // Validate credentials (example)
    if (email == 'user@example.com' && password == 'password') {
      req.session['userId'] = '123';
      req.session['email'] = email;
      req.session['loginAt'] = DateTime.now().toIso8601String();
      
      return res.json({'success': true});
    }
    
    res.status(401).json({'error': 'Invalid credentials'});
  });
  
  // Protected route
  app.get('/dashboard', requireAuth, (req, res) {
    res.json({
      'user': req.session['email'],
      'loggedIn': true,
    });
  });
  
  // Logout
  app.post('/logout', (req, res) {
    req.session.clear();
    res.json({'message': 'Logged out successfully'});
  });
  
  await app.listen(3000);
}

// Auth middleware
Future<void> requireAuth(Request req, Response res, NextFunction next) async {
  if (!req.session.containsKey('userId')) {
    return res.status(401).json({'error': 'Authentication required'});
  }
  await next();
}
```

## Session Lifetime

Sessions expire after inactivity:

```dart
final app = DartExpress(
  sessionSecret: 'secret',
  sessionStore: MemorySessionStore(
    cleanupInterval: Duration(minutes: 5),  // Cleanup frequency
  ),
);
```

Default TTL: 24 hours

## Security Best Practices

### 1. Use Strong Secrets

```dart
// ❌ Bad
sessionSecret: '12345'

// ✅ Good
sessionSecret: Platform.environment['SESSION_SECRET']!
```

Generate with:
```bash
dart run -e "import 'dart:math'; import 'dart:convert'; print(base64Encode(List.generate(32, (_) => Random.secure().nextInt(256))))"
```

### 2. HTTPS Only in Production

```dart
final app = DartExpress(
  sessionSecret: secret,
  secureCookies: Platform.environment['ENV'] == 'production',
);
```

### 3. Regenerate Session on Login

```dart
app.post('/login', (req, res) async {
  // Clear old session
  req.session.clear();
  
  // Create new session
  req.session['userId'] = userId;
  req.session['createdAt'] = DateTime.now().toIso8601String();
});
```

### 4. Implement Session Timeout

```dart
Future<void> checkSessionTimeout(Request req, Response res, NextFunction next) async {
  final loginTime = req.session['loginAt'] as String?;
  
  if (loginTime != null) {
    final login = DateTime.parse(loginTime);
    final now = DateTime.now();
    
    if (now.difference(login).inHours > 8) {
      req.session.clear();
      return res.status(401).json({'error': 'Session expired'});
    }
  }
  
  await next();
}
```

### 5. Store Minimal Data

```dart
// ❌ Don't store sensitive data
req.session['password'] = password;
req.session['creditCard'] = ccNumber;

// ✅ Store only IDs and references
req.session['userId'] = userId;
```

## Testing Sessions

```dart
import 'package:test/test.dart';
import 'package:http/http.dart' as http;

void main() {
  test('login creates session', () async {
    final response = await http.post(
      Uri.parse('http://localhost:3000/login'),
      body: {'email': 'test@example.com', 'password': 'pass'},
    );
    
    expect(response.statusCode, 200);
    
    // Extract session cookie
    final cookie = response.headers['set-cookie'];
    expect(cookie, isNotNull);
    
    // Use session in next request
    final dashboard = await http.get(
      Uri.parse('http://localhost:3000/dashboard'),
      headers: {'cookie': cookie!},
    );
    
    expect(dashboard.statusCode, 200);
  });
}
```

## Common Patterns

### Role-Based Access

```dart
req.session['role'] = 'admin';

Future<void> requireAdmin(Request req, Response res, NextFunction next) async {
  if (req.session['role'] != 'admin') {
    return res.status(403).json({'error': 'Admin only'});
  }
  await next();
}
```

### Shopping Cart

```dart
app.post('/cart/add', (req, res) async {
  final body = await req.body;
  final cart = req.session['cart'] as List? ?? [];
  
  cart.add(body['itemId']);
  req.session['cart'] = cart;
  
  res.json({'cartSize': cart.length});
});
```

### Remember Me

```dart
app.post('/login', (req, res) async {
  final body = await req.body;
  final rememberMe = body['rememberMe'] == true;
  
  req.session['userId'] = userId;
  
  if (rememberMe) {
    res.cookie('remember_token', token, maxAge: Duration(days: 30));
  }
});
```

## Next Steps

- [Error Handling](/core-concepts/error-handling) - Handle auth errors
- [Middleware](/core-concepts/middleware) - Create auth middleware
- [Examples](/examples/auth) - Complete auth example

-------- [ Separator ] ------

File Name: content/deployment/docker.md
Size: 5.96 KB
Code:
# Docker Deployment

Deploy dart_express applications using Docker for consistent, reproducible environments.

## Quick Start

### Dockerfile

Create `Dockerfile`:

```dockerfile
FROM dart:stable AS build

WORKDIR /app

# Copy pubspec files
COPY pubspec.* ./

# Install dependencies
RUN dart pub get

# Copy source code
COPY . .

# Compile to native executable
RUN dart compile exe bin/server.dart -o bin/server

# Runtime stage
FROM scratch

# Copy the executable
COPY --from=build /app/bin/server /app/bin/server

# Expose port
EXPOSE 3000

# Run the server
ENTRYPOINT ["/app/bin/server"]
```

### Build and Run

```bash
# Build image
docker build -t my-api .

# Run container
docker run -p 3000:3000 my-api
```

## Multi-Stage Build

Optimize image size with multi-stage builds:

```dockerfile
# Build stage
FROM dart:stable AS build

WORKDIR /app
COPY pubspec.* ./
RUN dart pub get

COPY . .
RUN dart compile exe bin/server.dart -o bin/server

# Runtime stage (minimal)
FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy executable from build stage
COPY --from=build /app/bin/server ./server

EXPOSE 3000

CMD ["./server"]
```

## Environment Variables

### Dockerfile

```dockerfile
FROM dart:stable AS build

WORKDIR /app
COPY pubspec.* ./
RUN dart pub get
COPY . .

# Build with environment support
RUN dart compile exe bin/server.dart -o bin/server

FROM debian:bookworm-slim

WORKDIR /app
COPY --from=build /app/bin/server ./server

# Default environment variables
ENV PORT=3000
ENV SESSION_SECRET=change-me-in-production

EXPOSE ${PORT}

CMD ["./server"]
```

### Application Code

```dart
import 'dart:io';

void main() async {
  final port = int.parse(Platform.environment['PORT'] ?? '3000');
  final sessionSecret = Platform.environment['SESSION_SECRET']!;
  
  final app = DartExpress(
    sessionSecret: sessionSecret,
    secureCookies: true,
  );
  
  app.get('/', (req, res) {
    res.json({'status': 'running'});
  });
  
  await app.listen(port, host: '0.0.0.0');
  print('Server running on port $port');
}
```

### Run with Environment

```bash
docker run -p 3000:3000 \
  -e PORT=3000 \
  -e SESSION_SECRET=your-secret-key \
  my-api
```

## Docker Compose

### Development Setup

`docker-compose.yml`:

```yaml
version: '3.8'

services:
  api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - PORT=3000
      - SESSION_SECRET=dev-secret-key
      - DB_HOST=mongodb
    depends_on:
      - mongodb
    volumes:
      - .:/app
    command: dart run bin/server.dart

  mongodb:
    image: mongo:latest
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

volumes:
  mongo-data:
```

Run:
```bash
docker-compose up
```

### Production Setup

`docker-compose.prod.yml`:

```yaml
version: '3.8'

services:
  api:
    image: my-api:latest
    restart: always
    ports:
      - "3000:3000"
    environment:
      - PORT=3000
      - SESSION_SECRET=${SESSION_SECRET}
      - DB_HOST=mongodb
    depends_on:
      - mongodb

  mongodb:
    image: mongo:latest
    restart: always
    volumes:
      - mongo-data:/data/db
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_USER}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}

  nginx:
    image: nginx:alpine
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - api

volumes:
  mongo-data:
```

## Health Checks

Add health check to Dockerfile:

```dockerfile
FROM debian:bookworm-slim

WORKDIR /app
COPY --from=build /app/bin/server ./server

# Add curl for health checks
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["./server"]
```

Application:
```dart
app.get('/health', (req, res) {
  res.json({'status': 'healthy'});
});
```

## Optimization Tips

### Use .dockerignore

`.dockerignore`:
```
.dart_tool/
.packages
build/
*.log
.git/
.gitignore
README.md
docker-compose*.yml
Dockerfile
.env
```

### Cache Dependencies

```dockerfile
# Copy only pubspec first (better caching)
COPY pubspec.* ./
RUN dart pub get

# Then copy source (changes more often)
COPY . .
```

### Reduce Image Size

```dockerfile
# Use scratch for minimal image
FROM scratch

# Or alpine for tiny Dart runner
FROM alpine:latest
RUN apk add --no-cache libc6-compat
```

## Kubernetes Deployment

`deployment.yaml`:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dart-express-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: my-api:latest
        ports:
        - containerPort: 3000
        env:
        - name: PORT
          value: "3000"
        - name: SESSION_SECRET
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: session-secret
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 30
---
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api
  ports:
  - port: 80
    targetPort: 3000
  type: LoadBalancer
```

## Security Best Practices

1. **Never hardcode secrets** - Use environment variables
2. **Run as non-root user**
3. **Scan images** for vulnerabilities
4. **Use multi-stage builds** to reduce attack surface
5. **Keep base images updated**

## Next Steps

- [Production Setup](/deployment/production) - Production best practices
- [Environment Variables](/deployment/environment) - Configuration guide
- [Scaling](/deployment/scaling) - Multi-instance deployment

-------- [ Separator ] ------

File Name: content/examples/todo-api.md
Size: 5.58 KB
Code:
# TODO API Example

A complete REST API for managing TODO items, demonstrating CRUD operations, validation, and error handling.

## Overview

This example shows:
- ✅ RESTful API design
- ✅ In-memory data storage
- ✅ Request validation
- ✅ Error handling
- ✅ CORS support

## Complete Code

```dart
import 'package:dart_express/dart_express.dart';

class Todo {
  final String id;
  String title;
  bool completed;
  DateTime createdAt;
  
  Todo({
    required this.id,
    required this.title,
    this.completed = false,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now();
  
  Map<String, dynamic> toJson() => {
    'id': id,
    'title': title,
    'completed': completed,
    'createdAt': createdAt.toIso8601String(),
  };
}

void main() async {
  final app = DartExpress();
  
  // In-memory storage
  final todos = <String, Todo>{};
  var nextId = 1;
  
  // CORS
  app.use(app.cors());
  
  // GET /todos - List all todos
  app.get('/todos', (req, res) {
    res.json({
      'todos': todos.values.map((t) => t.toJson()).toList(),
      'count': todos.length,
    });
  });
  
  // GET /todos/:id - Get single todo
  app.get('/todos/:id', (req, res) {
    final todo = todos[req.params['id']];
    
    if (todo == null) {
      return res.status(404).json({'error': 'Todo not found'});
    }
    
    res.json(todo.toJson());
  });
  
  // POST /todos - Create todo
  app.post('/todos', (req, res) async {
    final body = await req.body;
    
    // Validation
    if (body['title'] == null || body['title'].toString().trim().isEmpty) {
      return res.status(400).json({'error': 'Title is required'});
    }
    
    // Create todo
    final id = (nextId++).toString();
    final todo = Todo(
      id: id,
      title: body['title'].toString().trim(),
    );
    
    todos[id] = todo;
    
    res.status(201).json(todo.toJson());
  });
  
  // PUT /todos/:id - Update todo
  app.put('/todos/:id', (req, res) async {
    final todo = todos[req.params['id']];
    
    if (todo == null) {
      return res.status(404).json({'error': 'Todo not found'});
    }
    
    final body = await req.body;
    
    // Update fields
    if (body['title'] != null) {
      todo.title = body['title'].toString().trim();
    }
    if (body['completed'] != null) {
      todo.completed = body['completed'] as bool;
    }
    
    res.json(todo.toJson());
  });
  
  // DELETE /todos/:id - Delete todo
  app.delete('/todos/:id', (req, res) {
    final todo = todos.remove(req.params['id']);
    
    if (todo == null) {
      return res.status(404).json({'error': 'Todo not found'});
    }
    
    res.status(204).send();
  });
  
  await app.listen(3000);
  print('🚀 TODO API running on http://localhost:3000');
}
```

## API Endpoints

### List Todos
```bash
GET /todos
```

Response:
```json
{
  "todos": [
    {
      "id": "1",
      "title": "Buy groceries",
      "completed": false,
      "createdAt": "2024-01-01T10:00:00.000Z"
    }
  ],
  "count": 1
}
```

### Get Todo
```bash
GET /todos/:id
```

Response:
```json
{
  "id": "1",
  "title": "Buy groceries",
  "completed": false,
  "createdAt": "2024-01-01T10:00:00.000Z"
}
```

### Create Todo
```bash
POST /todos
Content-Type: application/json

{
  "title": "Buy groceries"
}
```

Response (201):
```json
{
  "id": "1",
  "title": "Buy groceries",
  "completed": false,
  "createdAt": "2024-01-01T10:00:00.000Z"
}
```

### Update Todo
```bash
PUT /todos/:id
Content-Type: application/json

{
  "completed": true
}
```

Response:
```json
{
  "id": "1",
  "title": "Buy groceries",
  "completed": true,
  "createdAt": "2024-01-01T10:00:00.000Z"
}
```

### Delete Todo
```bash
DELETE /todos/:id
```

Response: 204 No Content

## Testing with cURL

```bash
# Create a todo
curl -X POST http://localhost:3000/todos \
  -H "Content-Type: application/json" \
  -d '{"title":"Buy milk"}'

# List all todos
curl http://localhost:3000/todos

# Get specific todo
curl http://localhost:3000/todos/1

# Update todo
curl -X PUT http://localhost:3000/todos/1 \
  -H "Content-Type: application/json" \
  -d '{"completed":true}'

# Delete todo
curl -X DELETE http://localhost:3000/todos/1
```

## Extensions

### Add Filtering

```dart
app.get('/todos', (req, res) {
  var filtered = todos.values;
  
  // Filter by completion status
  final completed = req.query['completed'];
  if (completed != null) {
    final isCompleted = completed == 'true';
    filtered = filtered.where((t) => t.completed == isCompleted);
  }
  
  res.json({
    'todos': filtered.map((t) => t.toJson()).toList(),
  });
});
```

### Add Sorting

```dart
app.get('/todos', (req, res) {
  var list = todos.values.toList();
  
  // Sort by creation date
  list.sort((a, b) => b.createdAt.compareTo(a.createdAt));
  
  res.json({'todos': list.map((t) => t.toJson()).toList()});
});
```

### Add Pagination

```dart
app.get('/todos', (req, res) {
  final page = int.tryParse(req.query['page'] ?? '1') ?? 1;
  final limit = int.tryParse(req.query['limit'] ?? '10') ?? 10;
  
  final list = todos.values.toList();
  final start = (page - 1) * limit;
  final end = start + limit;
  
  res.json({
    'todos': list.skip(start).take(limit).map((t) => t.toJson()).toList(),
    'page': page,
    'totalPages': (list.length / limit).ceil(),
    'total': list.length,
  });
});
```

## Running the Example

The full example is available at:
```
/apps/dart_express_examples/todo_api_example
```

Run it:
```bash
cd apps/dart_express_examples/todo_api_example
dart run bin/server.dart
```

## Next Steps

- [Session Auth Example](/examples/auth) - Add authentication
- [MongoDB Example](/examples/mongodb) - Use real database
- [Testing](/guides/testing) - Test your API

-------- [ Separator ] ------

File Name: content/getting-started/installation.md
Size: 1.78 KB
Code:
# Installation

Get started with dart_express in minutes.

## Requirements

- **Dart SDK**: 3.6.0 or later
- **Platform**: Windows, macOS, Linux

## Install via Pub

Add dart_express to your `pubspec.yaml`:

```yaml
dependencies:
  dart_express: ^1.0.0
```

Then install dependencies:

```bash
dart pub get
```

## Create Your First Server

Create `bin/server.dart`:

```dart
import 'package:dart_express/dart_express.dart';

void main() async {
  final app = DartExpress();
  
  app.get('/', (req, res) {
    res.text('Hello from dart_express!');
  });
  
  await app.listen(3000);
  print('🚀 Server running on http://localhost:3000');
}
```

## Run Your Server

```bash
dart run bin/server.dart
```

Visit [http://localhost:3000](http://localhost:3000) to see your server in action!

## Verify Installation

Test that everything works:

```bash
curl http://localhost:3000
# Output: Hello from dart_express!
```

## Optional Dependencies

### For MongoDB Support
```yaml
dependencies:
  mongo_dart: ^0.9.0
```

### For Testing
```yaml
dev_dependencies:
  test: ^1.24.0
  http: ^1.1.0
```

## Project Structure

A typical dart_express project:

```
my_api/
├── bin/
│   └── server.dart          # Entry point
├── lib/
│   ├── controllers/         # Route controllers
│   ├── models/              # Data models
│   ├── services/            # Business logic
│   └── middleware/          # Custom middleware
├── test/
│   └── server_test.dart
└── pubspec.yaml
```

## Next Steps

- **[Quick Start](/about)** - Build a complete API
- **[Routing](/about)** - Learn about path parameters and routing
- **[Middleware](/about)** - Understand the middleware pipeline

<Info>
**Pro Tip**: Use `dart run --observe` to enable debugging with Dart DevTools!
</Info>

-------- [ Separator ] ------

File Name: content/getting-started/quick-start.md
Size: 4.39 KB
Code:
# Quick Start

Build your first dart_express application in 5 minutes.

## Basic Server

Create a simple HTTP server:

```dart
import 'package:dart_express/dart_express.dart';

void main() async {
  final app = DartExpress(
    // Use a strong secret for signed session cookies.
    sessionSecret: 'change-me-to-a-32+char-random-secret',
    // Set to false only for local HTTP development.
    secureCookies: true,
  );

  // Simple text response
  app.get('/', (req, res) {
    res.text('Welcome to dart_express!');
  });

  await app.listen(3000);
  print('Server running on http://localhost:3000');
}
```

## JSON API

Build a REST API endpoint:

```dart
app.get('/api/users', (req, res) {
  res.json({
    'users': [
      {'id': 1, 'name': 'Alice', 'email': 'alice@example.com'},
      {'id': 2, 'name': 'Bob', 'email': 'bob@example.com'},
    ],
  });
});
```

Test it:
```bash
curl http://localhost:3000/api/users
```

## Path Parameters

Handle dynamic routes:

```dart
app.get('/users/:id', (req, res) {
  final userId = req.params['id'];
  res.json({
    'userId': userId,
    'name': 'User $userId',
  });
});
```

Try it:
```bash
curl http://localhost:3000/users/123
# {"userId":"123","name":"User 123"}
```

## POST Requests

Handle form data:

```dart
app.post('/api/users', (req, res) async {
  final body = await req.body;
  final name = body['name'];
  
  res.status(201).json({
    'id': 3,
    'name': name,
    'created': DateTime.now().toIso8601String(),
  });
});
```

Test with curl:
```bash
curl -X POST http://localhost:3000/api/users \
  -H "Content-Type: application/json" \
  -d '{"name":"Charlie"}'
```

## Middleware

Add logging to all requests:

```dart
// Log every request
app.use((req, res, next) async {
  print('[${DateTime.now()}] ${req.method} ${req.uri.path}');
  await next();
});

// Your routes here
app.get('/', (req, res) => res.text('Hello!'));
```

## CORS

Enable CORS for your API:

```dart
app.use(app.cors(
  allowedOrigins: ['http://localhost:3000', 'https://myapp.com'],
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowCredentials: true,
));
```

## Sessions

Add user sessions:

```dart
final app = DartExpress(
  sessionSecret: 'your-secret-key-min-32-chars!',
);

app.get('/counter', (req, res) {
  final count = (req.session['count'] as int? ?? 0) + 1;
  req.session['count'] = count;
  
  res.json({'visits': count});
});
```

Each visitor gets tracked independently. For production, use a persistent `SessionStore` (e.g., Redis) so sessions survive restarts.

## Error Handling

Handle errors gracefully:

```dart
app.get('/error', (req, res) {
  throw Exception('Something went wrong!');
});

// Error handler middleware (must be last)
app.use((req, res, next) async {
  try {
    await next();
  } catch (e) {
    res.status(500).json({
      'error': e.toString(),
    });
  }
});
```

## Complete Example

A full-featured API server:

```dart
import 'package:dart_express/dart_express.dart';

void main() async {
  final app = DartExpress(
    sessionSecret: 'my-super-secret-key-min-32-chars',
  );

  // Middleware
  app.use((req, res, next) async {
    print('${req.method} ${req.uri.path}');
    await next();
  });

  app.use(app.cors());

  // Routes
  app.get('/', (req, res) {
    res.json({'message': 'Welcome to my API!'});
  });

  app.get('/users/:id', (req, res) {
    res.json({
      'id': req.params['id'],
      'name': 'User ${req.params['id']}',
    });
  });

  app.post('/users', (req, res) async {
    final body = await req.body;
    res.status(201).json({
      'created': body,
      'timestamp': DateTime.now().toIso8601String(),
    });
  });

  // Start server
  await app.listen(3000);
  print('🚀 API running on http://localhost:3000');
}
```

## Running in Production

For production use:

```dart
final app = DartExpress(
  sessionSecret: Platform.environment['SESSION_SECRET']!,
  secureCookies: true, // HTTPS only
);

final port = int.parse(Platform.environment['PORT'] ?? '3000');
await app.listen(port, host: '0.0.0.0');
```

<Warning>
Always use environment variables for secrets in production!
</Warning>

## Next Steps

- **[Routing](/about)** - Learn advanced routing patterns
- **[Middleware](/about)** - Create custom middleware
- **[Sessions](/about)** - Deep dive into session management
- **[Examples](/about)** - See complete example applications

<Tip>
Check out the TODO API example in `/apps/dart_express_examples/todo_api_example` for a complete REST API!
</Tip>

-------- [ Separator ] ------

File Name: content/index.md
Size: 2.00 KB
Code:
# dart_express

Express-style developer ergonomics, Dart performance, and production-first defaults.

## What you get

- **Familiar API**: `app.use`, `app.get`, `req.params`, `res.json`—if you know Express, you’re at home.
- **Safety built in**: HMAC-signed session cookies, secure-by-default SameSite/HttpOnly, CORS and rate limiting middleware.
- **Performance**: Radix-tree routing, multi-isolate server option for multi-core throughput.
- **Observability**: Request IDs on every response, structured logging hooks.
- **Extensibility**: Pluggable session and rate-limit stores; GetIt DI for your services.

## Install

```yaml
dependencies:
  dart_express: ^1.0.0
```

```bash
dart pub get
```

## Minimal app

```dart
import 'package:dart_express/dart_express.dart';

Future<void> main() async {
  final app = DartExpress(
    sessionSecret: 'change-me-to-a-32+char-random-secret',
  );

  app.get('/', (req, res) => res.text('Hello, Dart!'));

  app.get('/api/users', (req, res) {
    res.json({'users': ['Alice', 'Bob', 'Charlie']});
  });

  await app.listen(3000);
  print('Server running on http://localhost:3000');
}
```

For local HTTP testing, you can set `secureCookies: false` when constructing `DartExpress`; keep it `true` in production.

## Production highlights

- **Sessions**: Signed cookies; pluggable `SessionStore` (e.g., Redis) with automatic load/save per request.
- **Security**: Strict CORS configuration, rate limiter, request timeout, graceful shutdown.
- **Error handling**: Fallback error responses if custom handlers fail to write.
- **Multi-core**: `tool/serve_multi.dart` to run one isolate per core on the same port.

## Where to next?

- Start building: [Quick Start](/getting-started/quick-start)
- Learn the basics: [Getting Started](/getting-started/installation)
- Harden it: [Security](/security)
- See it in action: [Examples](/examples)
- API reference: [Core Concepts](/core-concepts)

---

⭐ [GitHub](https://github.com/kartikey321/dart_express) • 🐛 Issues • 💬 Discussions (coming soon)

-------- [ Separator ] ------

File Name: content/security/cors.md
Size: 4.82 KB
Code:
# CORS (Cross-Origin Resource Sharing)

Configure Cross-Origin Resource Sharing to allow your API to be accessed from different domains.

## Quick Start

Enable CORS for all origins (development only):

```dart
final app = DartExpress();

app.use(app.cors());

app.get('/api/data', (req, res) {
  res.json({'message': 'CORS enabled!'});
});
```

## Production Configuration

Restrict origins in production:

```dart
app.use(app.cors(
  allowedOrigins: [
    'https://myapp.com',
    'https://www.myapp.com',
  ],
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
));
```

## Configuration Options

### Allow Specific Origins

```dart
app.use(app.cors(
  allowedOrigins: ['https://example.com'],
));
```

### Allow All Origins (Development)

```dart
app.use(app.cors(
  allowedOrigins: ['*'], // Allow all
));
```

### Allow Methods

```dart
app.use(app.cors(
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
));
```

### Allow Headers

```dart
app.use(app.cors(
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Custom-Header',
  ],
));
```

### Credentials

Allow cookies and authentication:

```dart
app.use(app.cors(
  credentials: true,
  allowedOrigins: ['https://myapp.com'], // Required when credentials: true
));
```

## Preflight Requests

CORS automatically handles OPTIONS preflight requests:

```
Client                    Server
  |                         |
  |-- OPTIONS /api/data --> |
  |                         |
  |<-- 204 No Content ----- | (with CORS headers)
  |                         |
  |-- POST /api/data -----> |
  |<-- 200 OK ------------- |
```

## Common Use Cases

### API for Web App

```dart
app.use(app.cors(
  allowedOrigins: [
    'https://app.example.com',
    'https://dashboard.example.com',
  ],
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true,
));
```

### Public Read-Only API

```dart
app.use(app.cors(
  allowedOrigins: ['*'],
  allowedMethods: ['GET'],
  allowedHeaders: ['Content-Type'],
));
```

### Development with localhost

```dart
app.use(app.cors(
  allowedOrigins: [
    'http://localhost:3000',
    'http://localhost:5173', // Vite
    'http://localhost:8080',
  ],
));
```

## Custom CORS Middleware

For advanced scenarios, create custom CORS middleware:

```dart
Future<void> customCors(Request req, Response res, NextFunction next) async {
  final origin = req.headers['origin'];
  
  // Dynamic origin check
  if (origin != null && origin.endsWith('.example.com')) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Access-Control-Allow-Credentials', 'true');
  }
  
  // Handle preflight
  if (req.method == 'OPTIONS') {
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    return res.status(204).send();
  }
  
  await next();
}

app.use(customCors);
```

## Security Best Practices

### Never use `*` with credentials

❌ **Insecure:**
```dart
app.use(app.cors(
  allowedOrigins: ['*'],
  credentials: true, // SECURITY RISK!
));
```

✅ **Secure:**
```dart
app.use(app.cors(
  allowedOrigins: ['https://myapp.com'],
  credentials: true,
));
```

### Validate origins carefully

```dart
final allowedOrigins = [
  'https://myapp.com',
  'https://www.myapp.com',
  // Add staging/dev as needed
];

app.use(app.cors(
  allowedOrigins: allowedOrigins,
));
```

### Limit methods and headers

Only allow what you need:

```dart
app.use(app.cors(
  allowedMethods: ['GET', 'POST'], // Not PUT/DELETE if unused
  allowedHeaders: ['Content-Type'], // Minimal headers
));
```

## Testing CORS

### With curl

```bash
curl -H "Origin: https://example.com" \
     -H "Access-Control-Request-Method: POST" \
     -H "Access-Control-Request-Headers: Content-Type" \
     -X OPTIONS \
     http://localhost:3000/api/data
```

### With JavaScript

```javascript
fetch('http://localhost:3000/api/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  credentials: 'include', // For cookies
  body: JSON.stringify({data: 'test'}),
});
```

## Common Errors

### "No 'Access-Control-Allow-Origin' header"

**Cause:** CORS not enabled or origin not allowed

**Solution:** Add CORS middleware:
```dart
app.use(app.cors(
  allowedOrigins: ['https://yourapp.com'],
));
```

### "Credential is not supported if wildcard"

**Cause:** Using `*` with `credentials: true`

**Solution:** Specify exact origins:
```dart
app.use(app.cors(
  allowedOrigins: ['https://yourapp.com'], // Not '*'
  credentials: true,
));
```

## Next Steps

- [Rate Limiting](/security/rate-limiting) - Protect against abuse
- [Sessions](/core-concepts/sessions) - Manage authenticated users
- [Best Practices](/security/best-practices) - Security guidelines

-------- [ Separator ] ------

File Name: lib/components/clicker.dart
Size: 847 B
Code:
import 'package:jaspr/dom.dart';
import 'package:jaspr/jaspr.dart';
import 'package:jaspr_content/theme.dart';

/// A simple Jaspr component that counts the number of clicks.
@client
class Clicker extends StatefulComponent {
  const Clicker({super.key});

  @override
  State<Clicker> createState() => ClickerState();
}

class ClickerState extends State<Clicker> {
  int count = 0;

  @override
  Component build(BuildContext context) {
    return button(
      classes: 'clicker',
      onClick: () {
        setState(() => count++);
      },
      [
        .text('Click me! ($count)'),
      ],
    );
  }

  @css
  static List<StyleRule> get styles => [
    css('.clicker').styles(
      padding: .all(0.5.rem),
      margin: .only(top: 1.rem),
      border: .all(color: ContentColors.primary),
      radius: .circular(0.5.rem),
    ),
  ];
}

-------- [ Separator ] ------

File Name: lib/main.client.dart
Size: 852 B
Code:
/// The entrypoint for the **client** environment.
///
/// The [main] method will only be executed on the client when loading the page.
/// To run code on the server during pre-rendering, check the `main.server.dart` file.
library;

// Client-specific Jaspr import.
import 'package:jaspr/client.dart';

// This file is generated automatically by Jaspr, do not remove or edit.
import 'main.client.options.dart';

void main() {
  // Initializes the client environment with the generated default options.
  Jaspr.initializeApp(
    options: defaultClientOptions,
  );

  // Starts the app.
  //
  // [ClientApp] automatically loads and renders all components annotated with @client.
  //
  // You can wrap this with additional [InheritedComponent]s to share state across multiple
  // @client components if needed.
  runApp(
    const ClientApp(),
  );
}

-------- [ Separator ] ------

File Name: lib/main.client.options.dart
Size: 2.12 KB
Code:
// dart format off
// ignore_for_file: type=lint

// GENERATED FILE, DO NOT MODIFY
// Generated with jaspr_builder

import 'package:jaspr/client.dart';

import 'package:jaspr_content/components/_internal/code_block_copy_button.dart'
    deferred as _code_block_copy_button;
import 'package:jaspr_content/components/_internal/zoomable_image.dart'
    deferred as _zoomable_image;
import 'package:jaspr_content/components/github_button.dart'
    deferred as _github_button;
import 'package:jaspr_content/components/sidebar_toggle_button.dart'
    deferred as _sidebar_toggle_button;
import 'package:jaspr_content/components/theme_toggle.dart'
    deferred as _theme_toggle;
import 'package:site/components/clicker.dart' deferred as _clicker;

/// Default [ClientOptions] for use with your Jaspr project.
///
/// Use this to initialize Jaspr **before** calling [runApp].
///
/// Example:
/// ```dart
/// import 'main.client.options.dart';
///
/// void main() {
///   Jaspr.initializeApp(
///     options: defaultClientOptions,
///   );
///
///   runApp(...);
/// }
/// ```
ClientOptions get defaultClientOptions => ClientOptions(
  clients: {
    'jaspr_content:code_block_copy_button': ClientLoader(
      (p) => _code_block_copy_button.CodeBlockCopyButton(),
      loader: _code_block_copy_button.loadLibrary,
    ),
    'jaspr_content:zoomable_image': ClientLoader(
      (p) => _zoomable_image.ZoomableImage(
        src: p['src'] as String,
        alt: p['alt'] as String?,
        caption: p['caption'] as String?,
      ),
      loader: _zoomable_image.loadLibrary,
    ),
    'jaspr_content:github_button': ClientLoader(
      (p) => _github_button.GitHubButton(repo: p['repo'] as String),
      loader: _github_button.loadLibrary,
    ),
    'jaspr_content:sidebar_toggle_button': ClientLoader(
      (p) => _sidebar_toggle_button.SidebarToggleButton(),
      loader: _sidebar_toggle_button.loadLibrary,
    ),
    'jaspr_content:theme_toggle': ClientLoader(
      (p) => _theme_toggle.ThemeToggle(),
      loader: _theme_toggle.loadLibrary,
    ),
    'clicker': ClientLoader(
      (p) => _clicker.Clicker(),
      loader: _clicker.loadLibrary,
    ),
  },
);

-------- [ Separator ] ------

File Name: lib/main.server.dart
Size: 4.76 KB
Code:
/// The entrypoint for the **server** environment.
///
/// The [main] method will only be executed on the server during pre-rendering.
/// To run code on the client, check the `main.client.dart` file.
library;

// Server-specific Jaspr import.
import 'package:jaspr/server.dart';

import 'package:jaspr_content/components/callout.dart';
import 'package:jaspr_content/components/code_block.dart';
// import 'package:jaspr_content/components/code_block.dart'; // Disabled
import 'package:jaspr_content/components/github_button.dart';
import 'package:jaspr_content/components/header.dart';
import 'package:jaspr_content/components/image.dart';
import 'package:jaspr_content/components/sidebar.dart';
import 'package:jaspr_content/components/theme_toggle.dart';
import 'package:jaspr_content/jaspr_content.dart';
import 'package:jaspr_content/theme.dart';

import 'components/clicker.dart';

// This file is generated automatically by Jaspr, do not remove or edit.
import 'main.server.options.dart';

void main() {
  // Initializes the server environment with the generated default options.
  Jaspr.initializeApp(
    options: defaultServerOptions,
  );

  // Starts the app.
  //
  // [ContentApp] spins up the content rendering pipeline from jaspr_content to render
  // your markdown files in the content/ directory to a beautiful documentation site.
  runApp(
    ContentApp(
      // Enables mustache templating inside the markdown files.
      templateEngine: MustacheTemplateEngine(),
      parsers: [
        MarkdownParser(),
      ],
      extensions: [
        // Adds heading anchors to each heading.
        HeadingAnchorsExtension(),
        // Generates a table of contents for each page.
        TableOfContentsExtension(),
      ],
      components: [
        // The <Info> block and other callouts.
        Callout(),
        // Adds syntax highlighting to code blocks.
        CodeBlock(
          
        ), // Temporarily disabled due to highlighter errors
        // Adds a custom Jaspr component to be used as <Clicker/> in markdown.

        // Adds zooming and caption support to images.
        Image(zoom: true),
      ],
      layouts: [
        // Out-of-the-box layout for documentation sites.
        DocsLayout(
          header: Header(
            title: 'dart_express',
            logo: '',
            items: [
              // Enables switching between light and dark mode.
              ThemeToggle(),
              // Shows github stats.
              GitHubButton(repo: 'kartikey321/dart_express'),
            ],
          ),
          sidebar: Sidebar(
            groups: [
              SidebarGroup(
                title: 'Getting Started',
                links: [
                  SidebarLink(text: "Overview", href: '/'),
                  SidebarLink(text: "Installation", href: '/getting-started/installation'),
                  SidebarLink(text: "Quick Start", href: '/getting-started/quick-start'),
                ],
              ),
              SidebarGroup(
                title: 'Core Concepts',
                links: [
                  SidebarLink(text: "Routing", href: '/core-concepts/routing'),
                  SidebarLink(text: "Middleware", href: '/core-concepts/middleware'),
                  SidebarLink(text: "Sessions", href: '/core-concepts/sessions'),
                  SidebarLink(text: "Error Handling", href: '/core-concepts/error-handling'),
                ],
              ),
              SidebarGroup(
                title: 'Security',
                links: [
                  SidebarLink(text: "CORS", href: '/security/cors'),
                ],
              ),
              SidebarGroup(
                title: 'Deployment',
                links: [
                  SidebarLink(text: "Docker", href: '/deployment/docker'),
                ],
              ),
              SidebarGroup(
                title: 'Examples',
                links: [
                  SidebarLink(text: "TODO API", href: '/examples/todo-api'),
                ],
              ),
              SidebarGroup(
                title: 'Advanced',
                links: [
                  SidebarLink(text: "Isolated Containers", href: '/advanced/isolated-containers'),
                ],
              ),
              SidebarGroup(
                title: 'Learn More',
                links: [
                  SidebarLink(text: "About", href: '/about'),
                ],
              ),
            ],
          ),
        ),
      ],
      theme: ContentTheme(
        // Customizes the default theme colors.
        primary: ThemeColor(ThemeColors.blue.$500, dark: ThemeColors.blue.$300),
        background: ThemeColor(ThemeColors.slate.$50, dark: ThemeColors.zinc.$950),
        colors: [
          ContentColors.quoteBorders.apply(ThemeColors.blue.$400),
        ],
      ),
    ),
  );
}

-------- [ Separator ] ------

File Name: lib/main.server.options.dart
Size: 2.67 KB
Code:
// dart format off
// ignore_for_file: type=lint

// GENERATED FILE, DO NOT MODIFY
// Generated with jaspr_builder

import 'package:jaspr/server.dart';
import 'package:jaspr_content/components/_internal/code_block_copy_button.dart'
    as _code_block_copy_button;
import 'package:jaspr_content/components/_internal/zoomable_image.dart'
    as _zoomable_image;
import 'package:jaspr_content/components/callout.dart' as _callout;
import 'package:jaspr_content/components/code_block.dart' as _code_block;
import 'package:jaspr_content/components/github_button.dart' as _github_button;
import 'package:jaspr_content/components/image.dart' as _image;
import 'package:jaspr_content/components/sidebar_toggle_button.dart'
    as _sidebar_toggle_button;
import 'package:jaspr_content/components/theme_toggle.dart' as _theme_toggle;
import 'package:site/components/clicker.dart' as _clicker;

/// Default [ServerOptions] for use with your Jaspr project.
///
/// Use this to initialize Jaspr **before** calling [runApp].
///
/// Example:
/// ```dart
/// import 'main.server.options.dart';
///
/// void main() {
///   Jaspr.initializeApp(
///     options: defaultServerOptions,
///   );
///
///   runApp(...);
/// }
/// ```
ServerOptions get defaultServerOptions => ServerOptions(
  clientId: 'main.client.dart.js',
  clients: {
    _code_block_copy_button.CodeBlockCopyButton:
        ClientTarget<_code_block_copy_button.CodeBlockCopyButton>(
          'jaspr_content:code_block_copy_button',
        ),
    _zoomable_image.ZoomableImage: ClientTarget<_zoomable_image.ZoomableImage>(
      'jaspr_content:zoomable_image',
      params: __zoomable_imageZoomableImage,
    ),
    _github_button.GitHubButton: ClientTarget<_github_button.GitHubButton>(
      'jaspr_content:github_button',
      params: __github_buttonGitHubButton,
    ),
    _sidebar_toggle_button.SidebarToggleButton:
        ClientTarget<_sidebar_toggle_button.SidebarToggleButton>(
          'jaspr_content:sidebar_toggle_button',
        ),
    _theme_toggle.ThemeToggle: ClientTarget<_theme_toggle.ThemeToggle>(
      'jaspr_content:theme_toggle',
    ),
    _clicker.Clicker: ClientTarget<_clicker.Clicker>('clicker'),
  },
  styles: () => [
    ..._zoomable_image.ZoomableImage.styles,
    ..._callout.Callout.styles,
    ..._code_block.CodeBlock.styles,
    ..._github_button.GitHubButton.styles,
    ..._image.Image.styles,
    ..._theme_toggle.ThemeToggleState.styles,
    ..._clicker.ClickerState.styles,
  ],
);

Map<String, Object?> __zoomable_imageZoomableImage(
  _zoomable_image.ZoomableImage c,
) => {'src': c.src, 'alt': c.alt, 'caption': c.caption};
Map<String, Object?> __github_buttonGitHubButton(
  _github_button.GitHubButton c,
) => {'repo': c.repo};

-------- [ Separator ] ------

File Name: pubspec.yaml
Size: 322 B
Code:
name: site
description: A documentation site built with Jaspr
version: 0.0.1

environment:
  sdk: ^3.10.0

dependencies:
  jaspr: ^0.22.0
  jaspr_content: ^0.4.5
  jaspr_router: ^0.8.1

dev_dependencies:
  build_runner: ^2.10.0
  build_web_compilers: ^4.4.6
  jaspr_builder: ^0.22.0
  lints: ^5.0.0

jaspr:
  mode: static

-------- [ Separator ] ------
