Project Overview
===============

Project Statistics:
Total Files: 32
Total Size: 67.09 KB

File Types:
  .dart: 26 files
  .md: 2 files
  .yaml: 2 files
  no extension: 1 files
  .iml: 1 files

Detected Technologies:

Folder Structure (Tree)
=====================
Legend: ✓ = Included in output, ✗ = Excluded from output

├── .dart_tool/
├── .gitignore (221 B) ✓
├── CHANGELOG.md (29 B) ✓
├── README.md (4.14 KB) ✓
├── analysis_options.yaml (1.01 KB) ✓
├── example/
│   └── dart_express_example.dart (2.33 KB) ✓
├── lib/
│   ├── dart_express.dart (253 B) ✓
│   └── src/
│       ├── dart_express_base.dart (162 B) ✓
│       ├── extensions.dart (698 B) ✓
│       ├── middleware/
│       │   └── cookies_parser.dart (1.46 KB) ✓
│       ├── models/
│       │   ├── memory_store.dart (920 B) ✓
│       │   ├── middleware.dart (860 B) ✓
│       │   ├── models.dart (109 B) ✓
│       │   ├── request.dart (7.64 KB) ✓
│       │   └── response.dart (5.19 KB) ✓
│       ├── router/
│       │   ├── listRouter/
│       │   │   ├── listRouter.dart (27 B) ✓
│       │   │   ├── list_router.dart (1.44 KB) ✓
│       │   │   └── route_entry.dart (1.86 KB) ✓
│       │   ├── radixRouter/
│       │   │   ├── radixRouter.dart (28 B) ✓
│       │   │   ├── radix_node.dart (1.47 KB) ✓
│       │   │   └── radix_router.dart (5.37 KB) ✓
│       │   ├── router.dart (76 B) ✓
│       │   └── router_interface.dart (949 B) ✓
│       └── services/
│           ├── base_container.dart (6.38 KB) ✓
│           ├── controller.dart (2.32 KB) ✓
│           ├── dart_express.dart (8.08 KB) ✓
│           ├── dependency_injection.dart (604 B) ✓
│           ├── error_handler.dart (1018 B) ✓
│           ├── isolated_container.dart (4.98 KB) ✓
│           └── services.dart (248 B) ✓
├── melos_dart_express.iml (762 B) ✓
├── pubspec.yaml (381 B) ✓
├── test/
│   └── dart_express_test.dart (6.25 KB) ✓
└── tool/

==============

File Name: .gitignore
Size: 221 B
Code:
# https://dart.dev/guides/libraries/private-files
# Created by `dart pub`
.dart_tool/

# Avoid committing pubspec.lock for library packages; see
# https://dart.dev/guides/libraries/private-files#pubspeclock.
pubspec.lock

-------- [ Separator ] ------

File Name: CHANGELOG.md
Size: 29 B
Code:
## 1.0.0

- Initial version.

-------- [ Separator ] ------

File Name: README.md
Size: 4.14 KB
Code:
# dart_express

An Express-inspired HTTP framework for Dart. It brings familiar routing,
middleware, and dependency-injection patterns to `dart:io` while remaining
lightweight and dependency-free beyond `GetIt`.

## Features

- Fast radix-tree router with support for path parameters and nested routers
- Middleware pipeline with global and per-route handlers
- `GetIt`-powered dependency injection (supports async/lazy registrations)
- Controller abstraction for modular route registration
- Optional isolated containers for mounting self-contained sub-apps
- Batteries-included middleware for CORS, rate limiting, and cookie parsing

## Quick start

```bash
dart pub add dart_express
```

```dart
import 'dart:io';

import 'package:dart_express/dart_express.dart';

Future<void> main() async {
  final app = DartExpress();

  app.use(app.cors(allowedOrigins: ['http://localhost:3000']));
  app.get('/health', (req, res) => res.text('OK'));

  final port = int.parse(Platform.environment['PORT'] ?? '8080');
  await app.listen(port);
  print('Listening on http://localhost:$port');
}
```

## Routing essentials

- Use `app.get`, `app.post`, etc. to register handlers. Supply optional
  middleware with the `middleware:` argument.
- Controllers help organise routes:

  ```dart
  class UsersController extends Controller {
    @override
    void registerRoutes(ControllerOptions options) {
      options.get('/', _list);
      options.get('/:id(\\d+)', _show);
    }
  }

  app.useController('/users', UsersController());
  ```

- Throw one of the built-in `HttpError` types (`NotFoundError`,
  `ValidationError`, etc.) to short-circuit with a specific status code.

## Working with dependencies

The container is backed by `GetIt`. Register dependencies during startup and
retrieve them in handlers via `request.container`:

```dart
app.registerLazySingleton(() => Database(config));

app.get('/posts', (req, res) async {
  final db = req.container.get<Database>();
  final posts = await db.posts();
  res.json({'data': posts});
});
```

## Isolated modules

`IsolatedContainer` lets you mount a self-contained sub-application that has its
own middleware, router, and DI scope while sharing the main server:

```dart
final admin = IsolatedContainer(prefix: '/admin');
admin.use((req, res, next) {
  res.setHeader('X-Isolated', 'admin');
  return next();
});
admin.get('/', (req, res) => res.text('Admin dashboard'));
admin.mount(app);
```

For integration testing or microservice setups you can host the isolated module
by itself:

```dart
await admin.listen(9090); // optional
```

## Example project

See [`example/dart_express_example.dart`](example/dart_express_example.dart) for
a full reference that demonstrates controllers, isolated modules, and common
middleware.

## Error handling

Install a global error handler to customise responses:

```dart
app.setErrorHandler((error, req, res) async {
  if (error is ValidationError) {
    res.json({'error': error.message, 'details': error.data},
        statusCode: error.statusCode);
    return;
  }

  res.setStatus(HttpStatus.internalServerError);
  res.json({'error': 'Internal Server Error'});
});
```

## Performance tips

- Deploy behind a reverse proxy (nginx, Caddy) that terminates TLS and handles
  static assets.
- Reuse the same `DartExpress` instance across isolates if you need more CPU
  headroom—each isolate can call `await app.listen(port, address: ...)` with a
  different binding.
- For load testing use tools like [`wrk`](https://github.com/wg/wrk) or
  [`hey`](https://github.com/rakyll/hey)`:

  ```bash
  wrk -t8 -c256 -d30s http://localhost:8080/health
  ```

  Test both direct routes and isolated modules to compare overhead.
- Request parsing currently buffers the entire body; set upstream limits (e.g.
  via load balancer) and prefer streaming uploads for very large payloads.

Or use the built-in helper:

```bash
dart run tool/bench.dart --url http://localhost:8080/health --count 1000 --concurrency 32
```

## Contributing

- Run `dart format .` and `dart analyze` before submitting patches.
- Add regression tests under `test/` for routing/middleware changes.
- File issues or feature requests in the repository issue tracker.

## License

MIT License.

-------- [ Separator ] ------

File Name: analysis_options.yaml
Size: 1.01 KB
Code:
# This file configures the static analysis results for your project (errors,
# warnings, and lints).
#
# This enables the 'recommended' set of lints from `package:lints`.
# This set helps identify many issues that may lead to problems when running
# or consuming Dart code, and enforces writing Dart using a single, idiomatic
# style and format.
#
# If you want a smaller set of lints you can change this to specify
# 'package:lints/core.yaml'. These are just the most critical lints
# (the recommended set includes the core lints).
# The core lints are also what is used by pub.dev for scoring packages.

include: package:lints/recommended.yaml

# Uncomment the following section to specify additional rules.

# linter:
#   rules:
#     - camel_case_types

# analyzer:
#   exclude:
#     - path/to/excluded/files/**

# For more information about the core and recommended set of lints, see
# https://dart.dev/go/core-lints

# For additional information about configuring this file, see
# https://dart.dev/guides/language/analysis-options

-------- [ Separator ] ------

File Name: example/dart_express_example.dart
Size: 2.33 KB
Code:
import 'dart:async';
import 'dart:io';

import 'package:dart_express/dart_express.dart';

Future<void> main() async {
  final app = DartExpress();

  // Register shared dependencies.
  app.inject<Clock>(SystemClock());

  // Global middleware.
  app.use(app.cors(allowedOrigins: ['http://localhost:3000']));
  app.use(
      app.rateLimiter(maxRequests: 200, window: const Duration(minutes: 1)));
  app.setErrorHandler((err, req, res) {
    print(err);
    res.json({'error': err.toString()}, statusCode: 500);
  });
  // Simple health endpoint.
  app.get('/health', (req, res) {
    res.json({'status': 'ok', 'timestamp': req.container.get<Clock>().now()});
  });

  // Echo JSON payloads back to the client.
  app.post('/echo', (req, res) async {
    final payload = await req.body;
    res.json({'received': payload});
  });

  // Mount a controller for user routes.
  app.useController('/users', UsersController());

  // Mount an isolated admin module.
  final admin = IsolatedContainer(prefix: '/admin');
  admin.use((req, res, next) {
    res.setHeader('X-Isolated', 'admin');
    return next();
  });
  admin.get('/', (req, res) => res.text('Welcome to the admin module'));
  admin.get('/stats', (req, res) async {
    res.json({'uptimeSeconds': ProcessInfo.currentRss});
  });
  admin.mount(app);

  final port = int.parse(Platform.environment['PORT'] ?? '8080');
  await app.listen(port);
  print('dart_express example running on http://localhost:$port');
}

class UsersController extends Controller {
  static final List<Map<String, dynamic>> _users = [
    {'id': 1, 'name': 'Ada'},
    {'id': 2, 'name': 'Linus'},
  ];

  @override
  void registerRoutes(ControllerOptions options) {
    options.get('/', _listUsers);
    options.get('/:id(\\d+)', _getUserById);
  }

  Future<void> _listUsers(Request request, Response response) async {
    response.json({'data': _users});
  }

  Future<void> _getUserById(Request request, Response response) async {
    final id = int.tryParse(request.params['id'] ?? '');
    final user =
        _users.firstWhere((entry) => entry['id'] == id, orElse: () => {});

    if (user.isEmpty) {
      throw NotFoundError('User $id not found');
    }

    response.json({'data': user});
  }
}

abstract class Clock {
  String now();
}

class SystemClock implements Clock {
  @override
  String now() => DateTime.now().toUtc().toIso8601String();
}

-------- [ Separator ] ------

File Name: lib/dart_express.dart
Size: 253 B
Code:
/// Support for doing something awesome.
///
/// More dartdocs go here.
library;

export 'src/models/models.dart';
export 'src/services/services.dart';
export 'src/router/router.dart';
// TODO: Export any libraries intended for clients of this package.

-------- [ Separator ] ------

File Name: lib/src/dart_express_base.dart
Size: 162 B
Code:
// // TODO: Put public facing types in this file.
//
// /// Checks if you are awesome. Spoiler: you are.
// class Awesome {
//   bool get isAwesome => true;
// }

-------- [ Separator ] ------

File Name: lib/src/extensions.dart
Size: 698 B
Code:
extension ListContains<T> on List<T> {
  void replaceWhere(bool Function(T element) test, T newElement) {
    for (var i = 0; i < length; i++) {
      if (test(this[i])) {
        this[i] = newElement;
      }
    }
  }

  int? containsWithId(
    bool Function(T element) test,
  ) {
    for (var element in this) {
      if (test(element)) return indexOf(element);
    }
    return null;
  }

  T? containsWithCondition(
    bool Function(T element) test,
  ) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }

  bool hasIndex(int index) {
    if (length == 0 || index < 0 || index >= length) {
      return false;
    }
    return true;
  }
}

-------- [ Separator ] ------

File Name: lib/src/middleware/cookies_parser.dart
Size: 1.46 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';

class CookieParser {
  static MiddlewareHandler middleware({
    bool decodeValues = true,
    bool allowEmptyValues = false,
  }) {
    return (Request req, Response res, NextFunction next) async {
      try {
        req.cookies = _parseCookies(
          req.headers.value(HttpHeaders.cookieHeader),
          decodeValues: decodeValues,
          allowEmptyValues: allowEmptyValues,
        );
        await next();
      } catch (e) {
        await next(); // Could throw error if desired
      }
    };
  }

  static List<Cookie> _parseCookies(
    String? cookieHeader, {
    required bool decodeValues,
    required bool allowEmptyValues,
  }) {
    final cookies = <Cookie>[];
    if (cookieHeader == null || cookieHeader.isEmpty) {
      return cookies;
    }

    final pairs = cookieHeader.split(RegExp(r';\s*'));
    for (final pair in pairs) {
      if (pair.isEmpty) continue;

      final parts = pair.split('=');
      if (parts.isEmpty) continue;

      final name = parts[0].trim();
      if (name.isEmpty) continue;

      String value = parts.length > 1 ? parts.sublist(1).join('=').trim() : '';

      if (!allowEmptyValues && value.isEmpty) continue;

      if (decodeValues) {
        try {
          value = Uri.decodeComponent(value);
        } catch (e) {
          continue;
        }
      }

      final cookie = Cookie(name, value);
      cookies.add(cookie);
    }

    return cookies;
  }
}

-------- [ Separator ] ------

File Name: lib/src/models/memory_store.dart
Size: 920 B
Code:
import 'dart:collection';

abstract class RateLimitStore {
  Future<bool> increment(String key, int maxRequests, Duration window);
  Future<void> reset(String key);
}

/// In-memory store for rate limiter
class MemoryRateLimitStore implements RateLimitStore {
  final HashMap<String, List<int>> _store = HashMap();

  @override
  Future<bool> increment(String key, int maxRequests, Duration window) async {
    final now = DateTime.now().millisecondsSinceEpoch;
    final windowStart = now - window.inMilliseconds;

    _store.putIfAbsent(key, () => []);

    _store[key]!.removeWhere((timestamp) => timestamp < windowStart);

    if (_store[key]!.length >= maxRequests) {
      return false; // Rate limit exceeded
    }

    _store[key]!.add(now);
    return true;
  }

  @override
  Future<void> reset(String key) async {
    //need discussion
    if (_store.containsKey(key)) {
      _store.remove(key);
    }
  }
}

-------- [ Separator ] ------

File Name: lib/src/models/middleware.dart
Size: 860 B
Code:
import 'dart:async';

import 'request.dart';
import 'response.dart';

/// Continuation invoked by middleware to advance the pipeline.
typedef NextFunction = FutureOr<void> Function();

/// Signature for middleware functions that can perform asynchronous work.
typedef MiddlewareFunction = Future<void> Function(
    Request request, Response response, NextFunction next);

/// Signature for route handlers.
typedef RequestHandler = FutureOr<void> Function(
    Request request, Response response);

/// Alias used across the framework for middleware registration.
typedef MiddlewareHandler = FutureOr<void> Function(
    Request request, Response response, NextFunction next);

/// Wrapper describing a middleware bound to a specific [path].
class Middleware {
  final String path;
  final MiddlewareFunction handler;

  Middleware(this.path, this.handler);
}

-------- [ Separator ] ------

File Name: lib/src/models/models.dart
Size: 109 B
Code:
export './memory_store.dart';
export './middleware.dart';
export './request.dart';
export './response.dart';

-------- [ Separator ] ------

File Name: lib/src/models/request.dart
Size: 7.64 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'dart:typed_data';

import 'package:dart_express/dart_express.dart';
import 'package:get_it/get_it.dart';
import 'package:mime/mime.dart';

/// Represents an incoming HTTP request flowing through the framework.
///
/// Exposes helpers for accessing parsed payloads, form data, uploaded files
/// and dependency-injected services while ensuring the underlying stream is
/// consumed exactly once.
class Request {
  final HttpRequest httpRequest;
  Map<String, String> params = {};
  late final Map<String, String> query;
  final Session session;
  final GetIt container;
  Object? _parsedBody;
  Future<Uint8List>? _bodyBytesFuture;
  _FormDataPayload? _multipartPayload;
  Map<String, dynamic>? _formDataCache;
  final bool _isSessionNew;
  List<Cookie> cookies = [];

  Request(this.httpRequest, this.session, this.container,
      {bool isSessionNew = false})
      : _isSessionNew = isSessionNew {
    query = httpRequest.uri.queryParameters;
  }

  String get method => httpRequest.method;
  Uri get uri => httpRequest.uri;
  HttpHeaders get headers => httpRequest.headers;

  /// Returns the parsed request body.
  ///
  /// * JSON payloads are decoded via `jsonDecode`
  /// * `application/x-www-form-urlencoded` payloads return a map of fields
  /// * Text payloads resolve to a `String`
  /// * All other content types yield the raw `Uint8List`
  Future<Object?> get body async {
    if (_parsedBody != null) {
      return _parsedBody;
    }

    final contentType = headers.contentType?.mimeType ?? '';
    final bodyBytes = await _ensureBodyBytes();

    if (bodyBytes.isEmpty) {
      _parsedBody = null;
      return _parsedBody;
    }

    if (contentType == ContentType.json.mimeType ||
        contentType.endsWith('+json')) {
      _parsedBody = jsonDecode(utf8.decode(bodyBytes));
      return _parsedBody;
    }

    if (contentType == 'application/x-www-form-urlencoded') {
      _parsedBody = Uri.splitQueryString(utf8.decode(bodyBytes));
      return _parsedBody;
    }

    if (contentType.startsWith('text/')) {
      _parsedBody = utf8.decode(bodyBytes);
      return _parsedBody;
    }

    _parsedBody = bodyBytes;
    return _parsedBody;
  }

  /// Returns a merged view of multipart form fields and uploaded files.
  ///
  /// Keys pointing to files expose `List<MultipartFile>` while standard
  /// fields expose `String` values. For non-multipart requests this resolves
  /// to an empty map.
  Future<Map<String, dynamic>> get formData async {
    if (_formDataCache != null) {
      return _formDataCache!;
    }

    final payload = await _ensureMultipartPayload();
    final combined = <String, dynamic>{};
    combined.addAll(payload.fields);
    combined.addAll(payload.files);
    _formDataCache = Map.unmodifiable(combined);
    return _formDataCache!;
  }

  /// Creates a request wrapper, bootstrapping session state from the incoming
  /// cookie (or generating a new session identifier when absent).
  factory Request.from(
    HttpRequest httpRequest, {
    required GetIt container,
  }) {
    Cookie? sessionCookie;
    bool isSessionNew = false;

    try {
      sessionCookie = httpRequest.cookies
          .firstWhere((cookie) => cookie.name == _sessionCookieName);
    } on StateError {
      sessionCookie = Cookie(_sessionCookieName, _generateSessionId());
      isSessionNew = true;
    }

    final session = Session(sessionCookie!.value);

    return Request(httpRequest, session, container, isSessionNew: isSessionNew);
  }

  static String _generateSessionId() {
    return DateTime.now().millisecondsSinceEpoch.toString() +
        Random().nextInt(1000).toString();
  }

  /// Indicates whether a fresh session identifier was generated for this
  /// request (and therefore needs to be persisted back via response cookies).
  bool get isNewSession => _isSessionNew;

  Future<Map<String, List<MultipartFile>>> get files async {
    final payload = await _ensureMultipartPayload();
    return payload.files;
  }

  // Helper method to read stream fully into a list of bytes to prevent multiple listens
  static Future<List<int>> consolidateBytes(Stream<List<int>> stream) async {
    final buffer = BytesBuilder();
    await for (final chunk in stream) {
      buffer.add(chunk);
    }
    return buffer.takeBytes();
  }

  Future<Uint8List> _ensureBodyBytes() {
    final existing = _bodyBytesFuture;
    if (existing != null) {
      return existing;
    }

    final future = () async {
      final buffer = BytesBuilder();
      await for (final chunk in httpRequest) {
        buffer.add(chunk);
      }
      return buffer.takeBytes();
    }();

    _bodyBytesFuture = future;
    return future;
  }

  Future<_FormDataPayload> _ensureMultipartPayload() async {
    if (_multipartPayload != null) {
      return _multipartPayload!;
    }

    final contentType = headers.contentType;
    if (contentType?.mimeType != 'multipart/form-data') {
      _multipartPayload = _FormDataPayload.empty;
      _formDataCache = const {};
      return _multipartPayload!;
    }

    final boundary = contentType!.parameters['boundary'];
    if (boundary == null || boundary.isEmpty) {
      _multipartPayload = _FormDataPayload.empty;
      _formDataCache = const {};
      return _multipartPayload!;
    }

    final transformer = MimeMultipartTransformer(boundary);
    final bodyBytes = await _ensureBodyBytes();
    final stream = Stream<List<int>>.fromIterable(<List<int>>[bodyBytes]);
    final parts = await transformer.bind(stream).toList();

    final fieldData = <String, String>{};
    final fileData = <String, List<MultipartFile>>{};

    for (final part in parts) {
      final contentDisposition = part.headers['content-disposition'];
      if (contentDisposition == null) {
        continue;
      }

      final nameMatch =
          RegExp(r'name="([^"]*)"').firstMatch(contentDisposition);
      if (nameMatch == null) {
        continue;
      }

      final name = nameMatch.group(1)!;
      final filenameMatch =
          RegExp(r'filename="([^"]*)"').firstMatch(contentDisposition);
      final bytes = Uint8List.fromList(await consolidateBytes(part));

      if (filenameMatch != null) {
        final filename = filenameMatch.group(1)!;
        final filesForField =
            fileData.putIfAbsent(name, () => <MultipartFile>[]);
        filesForField.add(
          MultipartFile.fromBytes(
            name,
            bytes,
            filename: filename,
          ),
        );
      } else {
        fieldData[name] = utf8.decode(bytes);
      }
    }

    _multipartPayload = _FormDataPayload(fieldData, fileData);
    final combined = <String, dynamic>{};
    combined.addAll(_multipartPayload!.fields);
    combined.addAll(_multipartPayload!.files);
    _formDataCache = Map.unmodifiable(combined);
    return _multipartPayload!;
  }

  static const String _sessionCookieName = 'sessionId';

  /// Public accessor for the name of the framework-managed session cookie.
  static const String sessionCookieName = _sessionCookieName;
}

class Session {
  final String id;
  final Map<String, dynamic> data = {};

  Session(this.id);
}

class _FormDataPayload {
  _FormDataPayload(
      Map<String, String> fields, Map<String, List<MultipartFile>> files)
      : fields = Map.unmodifiable(fields),
        files = Map.unmodifiable(
          files.map(
            (key, value) => MapEntry(key, List.unmodifiable(value)),
          ),
        );

  static final _FormDataPayload empty =
      _FormDataPayload(<String, String>{}, <String, List<MultipartFile>>{});

  final Map<String, String> fields;
  final Map<String, List<MultipartFile>> files;

  bool get hasFiles => files.isNotEmpty;
  bool get isEmpty => fields.isEmpty && files.isEmpty;
}

-------- [ Separator ] ------

File Name: lib/src/models/response.dart
Size: 5.19 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:mime/mime.dart';

/// Represents an outgoing HTTP response with helpers for composing common
/// payload types and managing headers/cookies before the underlying
/// [HttpResponse] is closed.
class Response {
  int statusCode;
  dynamic body;
  Map<String, String> headers = {};
  bool isBinary = false;
  bool _isSent = false;
  final List<Cookie> _cookies = [];
  bool get isSent => _isSent;

  Response({this.statusCode = 200, this.body, Map<String, String>? headers}) {
    if (headers != null) {
      this.headers.addAll(headers);
    }
  }

  /// Adds or replaces a cookie on the response. Existing cookies with the same
  /// name and path are overwritten to avoid duplicate `Set-Cookie` headers.
  void cookie(
    String name,
    String value, {
    DateTime? expires,
    int? maxAge,
    String? domain,
    String? path,
    bool secure = true,
    bool httpOnly = true,
    SameSite? sameSite = SameSite.lax,
  }) {
    final cookie = Cookie(name, value)
      ..expires = expires
      ..maxAge = maxAge
      ..domain = domain
      ..path = path ?? '/'
      ..secure = secure
      ..httpOnly = httpOnly;

    if (sameSite != null) {
      cookie.sameSite = sameSite;
    }

    _replaceCookie(cookie);
  }

  /// Removes a cookie by setting an expired value for the provided name.
  void clearCookie(String name, {String? path, String? domain}) {
    final cookie = Cookie(name, '')
      ..maxAge = 0
      ..expires = DateTime.utc(1970)
      ..path = path
      ..domain = domain;
    _replaceCookie(cookie);
  }

  /// Returns `true` when a cookie with the given [name] (and optional [path])
  /// is queued for the response.
  bool hasCookie(String name, {String? path}) {
    return _cookies.any((cookie) {
      if (cookie.name != name) return false;
      if (path == null) return true;
      return (cookie.path ?? '/') == path;
    });
  }

  /// Serialises a JSON payload and updates the response metadata accordingly.
  void json(Map<String, dynamic> data, {int? statusCode}) {
    body = jsonEncode(data);
    headers['Content-Type'] = ContentType.json.mimeType;
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Writes a plain text payload to the response.
  void text(String data, {int? statusCode}) {
    body = data;
    headers['Content-Type'] = ContentType.text.mimeType;
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Writes an HTML payload to the response.
  void html(String html, {int? statusCode}) {
    body = html;
    headers['Content-Type'] = ContentType.html.mimeType;
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Writes an XML payload to the response.
  void xml(String xml, {int? statusCode}) {
    body = xml;
    headers['Content-Type'] = 'application/xml';
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Streams raw bytes to the client using the supplied content-type.
  void bytes(Uint8List bytes,
      {String contentType = 'application/octet-stream', int? statusCode}) {
    body = bytes;
    isBinary = true;
    headers['Content-Type'] = contentType;
    headers['Content-Length'] = bytes.length.toString();
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Reads a file from disk and emits it as the response body. Responds with
  /// a 404 when the file does not exist.
  Future<void> file(
    File file,
  ) async {
    if (await file.exists()) {
      final bytes = await file.readAsBytes();
      this.bytes(bytes, contentType: _getContentType(file.path));
    } else {
      statusCode = HttpStatus.notFound;
      text('File not found');
    }
  }

  /// Issues an HTTP redirect by setting the appropriate status code and
  /// `Location` header.
  void redirect(String url, {int status = HttpStatus.movedPermanently}) {
    statusCode = status;
    headers['Location'] = url;
  }

  static String _getContentType(String filePath) {
    return lookupMimeType(filePath) ?? 'application/octet-stream';
  }

  /// Flushes the accumulated headers/cookies into the provided [HttpResponse]
  /// and closes the sink. Subsequent invocations are ignored.
  void send(HttpResponse httpResponse) {
    if (isSent) return;
    _writeCookies(httpResponse);
    _isSent = true;

    httpResponse.statusCode = statusCode;

    headers.forEach((name, value) {
      httpResponse.headers.set(name, value);
    });

    if (isBinary) {
      httpResponse.add(body as Uint8List);
    } else if (body != null) {
      httpResponse.write(body);
    }

    httpResponse.close();
  }

  void setHeader(String name, String value) {
    headers[name] = value;
  }

  void setStatus(int code) {
    statusCode = code;
  }

  void _writeCookies(HttpResponse httpResponse) {
    if (_cookies.isEmpty) {
      return;
    }

    for (final cookie in _cookies) {
      httpResponse.cookies.add(cookie);
    }
  }

  void _replaceCookie(Cookie cookie) {
    _cookies.removeWhere((existing) {
      final sameName = existing.name == cookie.name;
      final existingPath = existing.path ?? '/';
      final newPath = cookie.path ?? '/';
      return sameName && existingPath == newPath;
    });
    _cookies.add(cookie);
  }
}

-------- [ Separator ] ------

File Name: lib/src/router/listRouter/listRouter.dart
Size: 27 B
Code:
export 'list_router.dart';

-------- [ Separator ] ------

File Name: lib/src/router/listRouter/list_router.dart
Size: 1.44 KB
Code:
// list_router.dart
import 'package:dart_express/dart_express.dart';
import 'package:dart_express/src/router/router_interface.dart';

import '../../services/error_handler.dart';

part 'route_entry.dart';

class ListRouter implements RouterInterface {
  final Map<String, _RouteEntry> _isolatedRoutes = {};
  final List<_RouteEntry> _routes = [];

  @override
  void addRoute(String method, String path, RequestHandler handler) {
    _routes.add(_RouteEntry.route(method, path, handler));
  }

  @override
  void addIsolatedRouter(String prefix, RouterInterface router) {
    if (_isolatedRoutes.containsKey(prefix)) {
      throw RouteConflictError(
          'Isolated router already exists at prefix: $prefix');
    }
    _isolatedRoutes[prefix] = _RouteEntry.isolated(prefix, router);
  }

  @override
  RouteMatch? findRoute(String method, String path) {
    // First check isolated routers
    for (final entry in _isolatedRoutes.values) {
      if (path.startsWith(entry.prefix!)) {
        final remainingPath = path.substring(entry.prefix!.length);
        final normalizedPath = remainingPath.isEmpty ? '' : remainingPath;
        return entry.isolatedRouter!.findRoute(method, normalizedPath);
      }
    }

    // Then check regular routes
    for (var route in _routes) {
      if (route.matches(method, path)) {
        return RouteMatch(
          route.handler,
          pathParams: route.extractParams(path),
        );
      }
    }
    return null;
  }
}

-------- [ Separator ] ------

File Name: lib/src/router/listRouter/route_entry.dart
Size: 1.86 KB
Code:
// route_entry.dart
part of 'list_router.dart';

class _RoutePattern {
  final RegExp regex;
  final List<String> paramNames;

  _RoutePattern(this.regex, this.paramNames);

  static _RoutePattern parse(String path) {
    final paramNames = <String>[];
    var pattern = path;

    pattern = pattern.replaceAllMapped(
        RegExp(r':([a-zA-Z][a-zA-Z0-9_]*)\(([^)]+)\)'), (match) {
      paramNames.add(match.group(1)!);
      return '(${match.group(2)})';
    });

    pattern =
        pattern.replaceAllMapped(RegExp(r':([a-zA-Z][a-zA-Z0-9_]*)'), (match) {
      paramNames.add(match.group(1)!);
      return '([^/]+)';
    });

    pattern = pattern.replaceAll('/', '\\/');
    final regex = RegExp('^$pattern/?\$');
    return _RoutePattern(regex, paramNames);
  }

  bool matches(String path) => regex.hasMatch(path);

  Map<String, String> extractParams(String path) {
    final match = regex.firstMatch(path);
    if (match == null) return {};
    final params = <String, String>{};
    for (var i = 0; i < paramNames.length; i++) {
      params[paramNames[i]] = match.group(i + 1)!;
    }
    return params;
  }
}

class _RouteEntry {
  final String method;
  final _RoutePattern pattern;
  final RequestHandler handler;
  final RouterInterface? isolatedRouter;
  final String? prefix;

  _RouteEntry.route(this.method, String path, this.handler)
      : pattern = _RoutePattern.parse(path),
        isolatedRouter = null,
        prefix = null;

  _RouteEntry.isolated(this.prefix, this.isolatedRouter)
      : method = '',
        pattern = _RoutePattern.parse(prefix!),
        handler = ((req, res) => Future.value());

  bool matches(String method, String path) {
    if (isolatedRouter != null) {
      return path.startsWith(prefix!);
    }
    return this.method == method && pattern.matches(path);
  }

  Map<String, String> extractParams(String path) => pattern.extractParams(path);
}

-------- [ Separator ] ------

File Name: lib/src/router/radixRouter/radixRouter.dart
Size: 28 B
Code:
export 'radix_router.dart';

-------- [ Separator ] ------

File Name: lib/src/router/radixRouter/radix_node.dart
Size: 1.47 KB
Code:
// radix_node.dart
part of 'radix_router.dart';

/// Represents a node in the radix tree routing structure
class RadixNode {
  /// The path segment this node represents
  final String segment;

  /// Child nodes keyed by their segment
  final Map<String, RadixNode> children = {};

  /// Named parameter for dynamic segments (null for static nodes)
  final String? paramName;

  /// Regex constraint for parameter validation (null for wildcards/static)
  final RegExp? regex;

  /// Registered handlers for different HTTP methods
  final Map<String, RequestHandler> handlers = {};
  RouterInterface? isolatedRouter;
  RadixNode._({
    required this.segment,
    this.paramName,
    this.regex,
  });

  /// Create root node
  factory RadixNode.root() => RadixNode._(segment: '');

  /// Create static route node
  factory RadixNode.static(String segment) => RadixNode._(segment: segment);

  /// Create dynamic route node
  factory RadixNode.dynamic(String segment, String paramName, RegExp? regex) =>
      RadixNode._(segment: segment, paramName: paramName, regex: regex);

  /// Whether this node represents a static path segment
  bool get isStatic => paramName == null;

  /// Whether this node represents a regex-constrained parameter
  bool get isRegex => isDynamic && regex != null;

  /// Whether this node represents a wildcard parameter
  bool get isWildcard => isDynamic && regex == null;

  /// Whether this node represents a dynamic parameter
  bool get isDynamic => paramName != null;
}

-------- [ Separator ] ------

File Name: lib/src/router/radixRouter/radix_router.dart
Size: 5.37 KB
Code:
// radix_router.dart
import 'package:dart_express/dart_express.dart';
import 'package:dart_express/src/router/router_interface.dart';
import 'package:dart_express/src/services/error_handler.dart';

part 'radix_node.dart';

/// A high-performance router using a radix tree structure for efficient route matching.
/// Supports:
/// - Static routes (/users/profile)
/// - Parameter routes with regex constraints (/users/:id(\d+))
/// - Wildcard parameters (/users/:username)
///
/// Route matching priority:
/// 1. Static routes
/// 2. Regex-constrained parameters
/// 3. Wildcard parameters
class RadixRouter implements RouterInterface {
  final RadixNode _root = RadixNode.root();

  @override
  void addRoute(String method, String path, RequestHandler handler) {
    final normalizedPath = _normalizePath(path);
    final routeKey = '$method:$normalizedPath';

    final segments = _splitPath(normalizedPath);
    var currentNode = _root;

    for (final segment in segments) {
      currentNode = _getOrCreateNode(currentNode, segment);
    }

    if (currentNode.handlers.containsKey(method)) {
      throw RouteConflictError('Handler already exists for $method $path');
    }
    currentNode.handlers[method] = handler;
  }

  @override
  void addIsolatedRouter(String prefix, RouterInterface router) {
    final normalizedPrefix = _normalizePath(prefix);
    final segments = _splitPath(normalizedPrefix);

    var currentNode = _root;
    for (final segment in segments) {
      currentNode = _getOrCreateNode(currentNode, segment);
    }

    if (currentNode.isolatedRouter != null) {
      throw RouteConflictError(
          'Isolated router already exists at prefix: $prefix');
    }
    currentNode.isolatedRouter = router;
  }

  @override
  RouteMatch? findRoute(String method, String path) {
    final normalizedPath = _normalizePath(path);
    final segments = _splitPath(normalizedPath);
    final params = <String, String>{};

    return _findRouteMatch(_root, segments, 0, method, params);
  }

  RouteMatch? _findRouteMatch(
    RadixNode node,
    List<String> segments,
    int depth,
    String method,
    Map<String, String> params,
  ) {
    // Check if current node has an isolated router
    if (node.isolatedRouter != null && depth <= segments.length) {
      final remainingSegments = segments.skip(depth);
      final remainingPath =
          remainingSegments.isEmpty ? '' : remainingSegments.join('/');
      return node.isolatedRouter!.findRoute(method, remainingPath);
    }

    // End of path - check for handler
    if (depth == segments.length) {
      final handler = node.handlers[method];
      return handler != null ? RouteMatch(handler, pathParams: params) : null;
    }

    final segment = segments[depth];
    final processed = <RadixNode>[];

    // Static routes first
    for (final child in node.children.values) {
      if (child.isStatic && child.segment == segment) {
        final match =
            _findRouteMatch(child, segments, depth + 1, method, params);
        if (match != null) return match;
        processed.add(child);
      }
    }

    // Then regex routes
    for (final child in node.children.values
        .where((c) => c.isRegex && !processed.contains(c))) {
      if (child.regex!.hasMatch(segment)) {
        final paramBackup = _handleParam(child, params, segment);
        final match =
            _findRouteMatch(child, segments, depth + 1, method, params);
        if (match != null) return match;
        _restoreParam(child, params, paramBackup);
        processed.add(child);
      }
    }

    // Finally wildcard routes
    for (final child in node.children.values
        .where((c) => c.isWildcard && !processed.contains(c))) {
      final paramBackup = _handleParam(child, params, segment);
      final match = _findRouteMatch(child, segments, depth + 1, method, params);
      if (match != null) return match;
      _restoreParam(child, params, paramBackup);
    }

    return null;
  }

  RadixNode _getOrCreateNode(RadixNode parent, String segment) {
    if (parent.children.containsKey(segment)) {
      return parent.children[segment]!;
    }

    final newNode = _createNode(segment);
    parent.children[segment] = newNode;
    return newNode;
  }

  RadixNode _createNode(String segment) {
    if (segment.startsWith(':')) {
      final match =
          RegExp(r':([a-zA-Z_]\w*)(?:\(([^)]+)\))?').firstMatch(segment);
      if (match == null) {
        throw FormatException('Invalid path segment: $segment');
      }

      final paramName = match.group(1)!;
      final regex =
          match.group(2) != null ? RegExp('^${match.group(2)}\$') : null;

      return RadixNode.dynamic(segment, paramName, regex);
    }
    return RadixNode.static(segment);
  }

  String _normalizePath(String path) => path
      .replaceAll(RegExp(r'/+'), '/') // Collapse multiple slashes
      .replaceAll(RegExp(r'^/|/$'), ''); // Trim leading/trailing slashes

  List<String> _splitPath(String path) => path.split('/');

  String? _handleParam(
      RadixNode node, Map<String, String> params, String value) {
    if (!node.isDynamic) return null;
    final backup = params[node.paramName!];
    params[node.paramName!] = value;
    return backup;
  }

  void _restoreParam(
      RadixNode node, Map<String, String> params, String? backup) {
    if (!node.isDynamic) return;
    if (backup != null) {
      params[node.paramName!] = backup;
    } else {
      params.remove(node.paramName!);
    }
  }
}

-------- [ Separator ] ------

File Name: lib/src/router/router.dart
Size: 76 B
Code:
export 'listRouter/listRouter.dart';
export 'radixRouter/radixRouter.dart';

-------- [ Separator ] ------

File Name: lib/src/router/router_interface.dart
Size: 949 B
Code:
import 'package:dart_express/dart_express.dart';

/// Defines the common interface for all router implementations
abstract class RouterInterface {
  /// Add a route to the router
  /// [method] - HTTP method (GET, POST, etc.)
  /// [path] - URL path pattern with optional parameters
  /// [handler] - Request handler function
  void addRoute(String method, String path, RequestHandler handler);

  /// Find a matching route for incoming request
  /// Returns [RouteMatch] with handler and parameters if found
  RouteMatch? findRoute(String method, String path);

  void addIsolatedRouter(String prefix, RouterInterface router);
}

/// Container for matched route results
class RouteMatch {
  /// The request handler to execute
  final RequestHandler handler;

  /// Path parameters extracted from the URL
  final Map<String, String> pathParams;

  RouteMatch(this.handler, {Map<String, String>? pathParams})
      : pathParams = pathParams ?? {};
}

-------- [ Separator ] ------

File Name: lib/src/services/base_container.dart
Size: 6.38 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:get_it/get_it.dart';
import 'package:meta/meta.dart';

import '../router/router_interface.dart';
import 'error_handler.dart';

/// Core runtime wiring shared by [DartExpress] and other container variants.
/// Provides middleware composition, dependency registration helpers, and
/// request lifecycle utilities.
abstract class BaseContainer {
  final RouterInterface router;
  final List<MiddlewareHandler> _middleware = [];
  final GetIt container;
  ErrorHandler? _errorHandler;

  /// Creates a container with optional overrides for router and dependency
  /// scope.
  BaseContainer({RouterInterface? router, GetIt? container})
      : router = router ?? RadixRouter(),
        container = container ?? GetIt.instance;

  /// Adds a global [middleware] to the container.
  void use(MiddlewareHandler middleware) {
    _middleware.add(middleware);
  }

  /// Registers a pre-built [instance] that will be served for type [T].
  void inject<T extends Object>(T instance) {
    container.registerSingleton<T>(instance);
  }

  /// Registers an eagerly created singleton for [T].
  void registerSingleton<T extends Object>(T instance) {
    container.registerSingleton<T>(instance);
  }

  /// Registers a factory invoked on each access to [T].
  void registerFactory<T extends Object>(T Function() factoryFunc) {
    container.registerFactory<T>(factoryFunc);
  }

  /// Registers a lazily created singleton for [T].
  void registerLazySingleton<T extends Object>(T Function() factoryFunc) {
    container.registerLazySingleton<T>(factoryFunc);
  }

  /// Registers an asynchronously produced singleton.
  void registerSingletonAsync<T extends Object>(
      Future<T> Function() asyncFactoryFunc) {
    container.registerSingletonAsync<T>(asyncFactoryFunc);
  }

  /// Registers an asynchronously produced factory provider.
  void registerFactoryAsync<T extends Object>(
      Future<T> Function() asyncFactoryFunc) {
    container.registerFactoryAsync<T>(asyncFactoryFunc);
  }

  /// Registers an asynchronously produced lazy singleton.
  void registerLazySingletonAsync<T extends Object>(
      Future<T> Function() asyncFactoryFunc) {
    container.registerLazySingletonAsync<T>(asyncFactoryFunc);
  }

  /// Checks whether [T] is already registered.
  bool isRegistered<T extends Object>({Object? instance}) {
    return container.isRegistered<T>(instance: instance);
  }

  /// Unregisters the existing binding for [T].
  void unregister<T extends Object>() {
    container.unregister<T>();
  }

  /// Installs a global error handler.
  void setErrorHandler(ErrorHandler handler) {
    _errorHandler = handler;
  }

  @protected
  RequestHandler wrapWithMiddleware(
      RequestHandler handler, List<MiddlewareHandler> routeMiddleware) {
    return (Request request, Response response) async {
      int globalIndex = 0;
      int routeIndex = 0;

      Future<void> runNextMiddleware() async {
        if (globalIndex < _middleware.length) {
          await _middleware[globalIndex++](
              request, response, runNextMiddleware);
        } else if (routeIndex < routeMiddleware.length) {
          await routeMiddleware[routeIndex++](
              request, response, runNextMiddleware);
        } else {
          await handler(request, response);
        }
      }

      await runNextMiddleware();
    };
  }

  @protected
  void addRoute(String method, String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final wrappedHandler = wrapWithMiddleware(handler, middleware ?? []);
    router.addRoute(method, path, wrappedHandler);
  }

  /// Orchestrates the full request lifecycle: building framework abstractions,
  /// resolving routes, executing middleware/handlers and finally flushing the
  /// response (including error handling and session propagation).
  @protected
  Future<void> handleRequest(HttpRequest httpRequest) async {
    final request = Request.from(httpRequest, container: container);
    final response = Response();
    await processRequest(request, response);
  }

  /// Executes middleware + handler pipeline for a prepared [request] and
  /// [response]. If a route does not complete the response, it is sent here.
  @protected
  Future<void> processRequest(Request request, Response response) async {
    if (request.isNewSession &&
        !response.hasCookie(Request.sessionCookieName)) {
      response.cookie(
        Request.sessionCookieName,
        request.session.id,
        secure: false,
        httpOnly: true,
      );
    }

    try {
      final resolvedPath = resolveRoutePath(request);
      final routeMatch = router.findRoute(request.method, resolvedPath);
      request.params = routeMatch?.pathParams ?? {};
      if (routeMatch != null) {
        await routeMatch.handler(request, response);
      } else {
        throw NotFoundError('Route not found: $resolvedPath');
      }
    } catch (error, stackTrace) {
      await handleError(error, request, response, stackTrace);
    }

    if (!response.isSent) {
      response.send(request.httpRequest.response);
    }
  }

  /// Resolves the path used for route lookup. Subclasses can override to provide
  /// custom behaviour (e.g., stripping a mount prefix).
  @protected
  String resolveRoutePath(Request request) => request.uri.path;

  /// Default error handling entry point. Subclasses may override to plug in
  /// different behaviour.
  @protected
  Future<void> handleError(dynamic error, Request request, Response response,
      StackTrace stackTrace) async {
    if (_errorHandler != null) {
      try {
        await _errorHandler!(error, request, response);
      } catch (e) {
        print('Error in error handler: $e');
        response.setStatus(HttpStatus.internalServerError);
        response.json({
          'error': 'Internal Server Error',
          'message': 'Error handling the original error'
        });
      }
    } else {
      print('Unhandled error: $error\nStackTrace: $stackTrace');
      if (error is HttpError) {
        response.setStatus(error.statusCode);
        response.json({'error': error.message, 'data': error.data});
      } else {
        response.setStatus(HttpStatus.internalServerError);
        response.json(
            {'error': 'Internal Server Error', 'message': error.toString()});
      }
    }
  }

  /// Disposes the dependency container and any subclass resources.
  Future<void> onDispose() async {
    container.reset();
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/controller.dart
Size: 2.32 KB
Code:
import 'package:meta/meta.dart';

import '../models/middleware.dart';
import 'dart_express.dart';

/// Helper passed to controllers so they can register routes relative to their
/// configured prefix without duplicating boilerplate.
class ControllerOptions {
  late final DartExpress _app;
  late final String _prefix;
  ControllerOptions(this._app, this._prefix);
  /// Registers a `GET` handler relative to the controller prefix.
  void get(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.get(fullPath, handler, middleware: middleware);
  }

  /// Registers a `POST` handler relative to the controller prefix.
  void post(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.post(fullPath, handler, middleware: middleware);
  }

  /// Registers a `PUT` handler relative to the controller prefix.
  void put(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.put(fullPath, handler, middleware: middleware);
  }

  /// Registers a `PATCH` handler relative to the controller prefix.
  void patch(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.patch(fullPath, handler, middleware: middleware);
  }

  /// Registers a `DELETE` handler relative to the controller prefix.
  void delete(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.delete(fullPath, handler, middleware: middleware);
  }

  String _joinPaths(String path) {
    if (_prefix.isEmpty) return path;
    if (path.startsWith('/')) path = path.substring(1);
    return '${_prefix.endsWith('/') ? _prefix : '$_prefix/'}$path';
  }
}

/// Base class for feature modules that register routes using
/// [ControllerOptions]. Override [registerRoutes] to declare handlers.
abstract class Controller {
  late final ControllerOptions _options;
  @mustCallSuper
  void initialize(DartExpress app, {required String prefix}) {
    _options = ControllerOptions(app, prefix);
    registerRoutes(_options);
  }

  /// Subclasses implement this to register routes.
  void registerRoutes(ControllerOptions options);
}

-------- [ Separator ] ------

File Name: lib/src/services/dart_express.dart
Size: 8.08 KB
Code:
import 'dart:async';
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:dart_express/src/middleware/cookies_parser.dart';

/// Common HTTP method constants used across the framework.
class RequestTypes {
  static const String GET = 'GET';
  static const String POST = 'POST';
  static const String PUT = 'PUT';
  static const String PATCH = 'PATCH';
  static const String DELETE = 'DELETE';
  static const String OPTIONS = 'OPTIONS';

  static const List<String> allTypes = [GET, POST, PUT, PATCH, DELETE, OPTIONS];
}

/// DartExpress is a lightweight web framework for Dart, inspired by Express.js.
/// Provides routing helpers, middleware registration and server lifecycle
/// management around a standard [HttpServer].
class DartExpress extends BaseContainer {
  DartExpress({
    bool useCookieParser = true,
    super.container,
    super.router,
  }) {
    if (useCookieParser) {
      use(CookieParser.middleware());
    }
  }

  /// Mounts a controller under the provided [prefix]. Routes registered inside
  /// the controller will automatically inherit the prefix.
  void useController(String prefix, Controller controller) {
    controller.initialize(this, prefix: prefix);
  }

  /// Registers a `GET` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void get(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.GET, path, handler, middleware: middleware);
  }

  /// Registers a `POST` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void post(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.POST, path, handler, middleware: middleware);
  }

  /// Registers a `PUT` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void put(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PUT, path, handler, middleware: middleware);
  }

  /// Registers a `PATCH` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void patch(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PATCH, path, handler, middleware: middleware);
  }

  /// Registers a `DELETE` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void delete(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.DELETE, path, handler, middleware: middleware);
  }

  /// Registers an `OPTIONS` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void options(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.OPTIONS, path, handler, middleware: middleware);
  }

  final Map<HttpServer, Future<void>> _serverLifecycles = {};

  /// Binds an [HttpServer] on the provided [port] (and optional [address]) and
  /// starts processing incoming requests in the background. The returned server
  /// can be closed by the caller when shutdown is required or during tests.
  Future<HttpServer> listen(
    int port, {
    InternetAddress? address,
  }) async {
    address ??= InternetAddress.anyIPv4;
    final server = await HttpServer.bind(address, port);
    print('Server listening on port ${server.port}');

    final lifecycle = _serve(server);
    _serverLifecycles[server] = lifecycle;
    lifecycle.whenComplete(() => _serverLifecycles.remove(server));

    return server;
  }

  /// Awaits the internal request-processing loop for [server], ensuring any
  /// teardown logic has completed once the server has been closed. Useful for
  /// integration tests where the server is created and disposed per test case.
  Future<void> waitUntilClosed(HttpServer server) async {
    final lifecycle = _serverLifecycles[server];
    if (lifecycle != null) {
      await lifecycle;
    }
  }

  /// Generates a CORS middleware using the provided allow lists. Handles
  /// pre-flight requests and applies common security headers.
  MiddlewareHandler cors({
    List<String> allowedOrigins = const ['*'],
    List<String> allowedMethods = RequestTypes.allTypes,
    List<String> allowedHeaders = const ['Content-Type', 'Authorization'],
    bool allowCredentials = false,
    int maxAge = 86400,
  }) {
    return (request, response, next) async {
      final origin = request.headers.value('Origin');
      final method = request.method;

      // Check if the origin is allowed
      bool isAllowedOrigin(String? origin) {
        return origin != null &&
            (allowedOrigins.contains('*') || allowedOrigins.contains(origin));
      }

      final shouldEchoOrigin =
          allowedOrigins.isNotEmpty && !allowedOrigins.contains('*');

      if (shouldEchoOrigin && origin != null) {
        response.setHeader('Vary', 'Origin');
      }

      if (isAllowedOrigin(origin)) {
        // Set CORS headers
        final allowOriginHeader =
            allowedOrigins.contains('*') && !allowCredentials ? '*' : origin!;
        response.setHeader('Access-Control-Allow-Origin', allowOriginHeader);
        response.setHeader(
            'Access-Control-Allow-Methods', allowedMethods.join(', '));
        response.setHeader(
            'Access-Control-Allow-Headers', allowedHeaders.join(', '));
        response.setHeader('Access-Control-Max-Age', maxAge.toString());

        if (allowCredentials) {
          response.setHeader('Access-Control-Allow-Credentials', 'true');
        }

        // Handle preflight OPTIONS request
        if (method == 'OPTIONS') {
          response.setStatus(HttpStatus.noContent); // 204 No Content
          response.send(request.httpRequest.response);
          return;
        }
      } else if (origin != null && !isAllowedOrigin(origin)) {
        // If origin is not allowed, log and respond with 403 Forbidden
        print('CORS Denied - Origin not allowed: $origin');
        response.setStatus(HttpStatus.forbidden);
        response.text('CORS policy does not allow this origin.');
        response.send(request.httpRequest.response);
        return;
      } else if (!allowedMethods.contains(method)) {
        // If method is not allowed, respond with 405 Method Not Allowed
        print('CORS Denied - Method not allowed: $method');
        response.setStatus(HttpStatus.methodNotAllowed);
        response.text('Method not allowed.');
        response.send(request.httpRequest.response);
        return;
      }

      // Set additional security headers
      response.setHeader(
          'Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
      response.setHeader('X-Content-Type-Options', 'nosniff');
      response.setHeader('X-Frame-Options', 'DENY');

      await next();
    };
  }

  /// Builds a rate limiter middleware backed by [store] (or an in-memory
  /// default). Requests exceeding [maxRequests] within [window] receive a 429
  /// response. Customize [keyGenerator] to throttle by user/token/etc.
  MiddlewareHandler rateLimiter({
    int maxRequests = 100,
    Duration window = const Duration(minutes: 1),
    String Function(Request request)? keyGenerator,
    RateLimitStore? store,
  }) {
    final effectiveStore = store ?? MemoryRateLimitStore();
    return (request, response, next) async {
      final key = keyGenerator != null
          ? keyGenerator(request)
          : request.httpRequest.connectionInfo?.remoteAddress.address ??
              'unknown';

      final isAllowed =
          await effectiveStore.increment(key, maxRequests, window);

      if (!isAllowed) {
        response.setStatus(HttpStatus.tooManyRequests);
        response.text('Rate limit exceeded. Try again later.');
        return;
      }

      await next();
    };
  }

  Future<void> _serve(HttpServer server) async {
    try {
      await for (final httpRequest in server) {
        await handleRequest(httpRequest);
      }
    } finally {
      await onDispose();
    }
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/dependency_injection.dart
Size: 604 B
Code:
class DIContainer {
  final Map<Type, dynamic> _instances = {};
  final Map<Type, Function> _factories = {};

  void registerSingleton<T>(T instance) {
    _instances[T] = instance;
  }

  void registerFactory<T>(T Function() factory) {
    _factories[T] = factory;
  }

  T get<T>() {
    if (_instances.containsKey(T)) {
      return _instances[T] as T;
    }
    if (_factories.containsKey(T)) {
      final instance = _factories[T]!() as T;
      _instances[T] = instance; // Cache the instance
      return instance;
    }
    throw Exception('No instance or factory registered for type $T');
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/error_handler.dart
Size: 1018 B
Code:
import 'dart:async';
import 'dart:io';

import '../../dart_express.dart';

typedef ErrorHandler = FutureOr<void> Function(
    dynamic error, Request request, Response response);

class HttpError implements Exception {
  final int statusCode;
  final String message;
  final dynamic data;

  HttpError(this.statusCode, this.message, [this.data]);

  @override
  String toString() => 'HttpError: $statusCode - $message';
}

class ValidationError extends HttpError {
  ValidationError(String message, [dynamic data])
      : super(HttpStatus.badRequest, message, data);
}

class NotFoundError extends HttpError {
  NotFoundError(String message, [dynamic data])
      : super(HttpStatus.notFound, message, data);
}

class UnauthorizedError extends HttpError {
  UnauthorizedError(String message, [dynamic data])
      : super(HttpStatus.unauthorized, message, data);
}

class RouteConflictError extends HttpError {
  RouteConflictError(String message, [dynamic data])
      : super(HttpStatus.conflict, message, data);
}

-------- [ Separator ] ------

File Name: lib/src/services/isolated_container.dart
Size: 4.98 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:get_it/get_it.dart';

import '../router/router_interface.dart';

/// A container that can be mounted under a specific prefix with its own router,
/// middleware pipeline and dependency injection scope.
///
/// When mounted it reuses the parent [`Response`] instance so that cookies,
/// headers, and streaming behaviour are coordinated with the hosting
/// application while requests are rebuilt against the isolated dependency
/// scope.
class IsolatedContainer extends BaseContainer {
  IsolatedContainer({
    String prefix = '',
    super.router,
    GetIt? container,
  })  : prefix = _normalizePrefix(prefix),
        super(
          container: container ?? GetIt.asNewInstance(),
        );

  /// Public prefix exposed for introspection (always normalised to leading slash
  /// without trailing slash, except when empty).
  final String prefix;

  final Map<String, dynamic> cache = {};

  void get(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.GET, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void post(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.POST, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void put(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PUT, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void patch(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PATCH, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void delete(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.DELETE, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void options(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.OPTIONS, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  /// Mounts this container into the provided [app], delegating only requests
  /// whose path matches the configured prefix via the parent router. This keeps
  /// path normalisation and parameter extraction consistent with the main
  /// routing strategy.
  void mount(DartExpress app) {
    final mountPrefix = prefix.isEmpty ? '/' : prefix;
    app.router.addIsolatedRouter(
      mountPrefix,
      _IsolatedRouterDelegate(this),
    );
  }

  /// Optional helper to run this container as a standalone service.
  Future<void> listen(int port, {InternetAddress? address}) async {
    address ??= InternetAddress.anyIPv4;
    final server = await HttpServer.bind(address, port);
    print('Isolated container listening on port ${server.port}');
    await for (final httpRequest in server) {
      await handleRequest(httpRequest);
    }
  }

  @override
  String resolveRoutePath(Request request) {
    if (prefix.isEmpty) return request.uri.path;

    final path = request.uri.path;
    if (path == prefix || path == '$prefix/') {
      return '/';
    }

    final prefixedWithSlash = prefix.isEmpty ? '/' : '$prefix/';
    if (path.startsWith(prefixedWithSlash)) {
      final trimmed = path.substring(prefix.length);
      if (trimmed.isEmpty) return '/';
      return trimmed.startsWith('/') ? trimmed : '/$trimmed';
    }

    return request.uri.path;
  }

  @override
  Future<void> onDispose() {
    cache.clear();
    return super.onDispose();
  }

  static String _normalizeLocalPath(String path) {
    if (path.isEmpty) return '/';
    return path.startsWith('/') ? path : '/$path';
  }

  static String _normalizePrefix(String prefix) {
    var value = prefix.trim();
    if (value.isEmpty || value == '/') {
      return '';
    }
    if (!value.startsWith('/')) {
      value = '/$value';
    }
    if (value.endsWith('/') && value.length > 1) {
      value = value.substring(0, value.length - 1);
    }
    return value;
  }
}

class _IsolatedRouterDelegate implements RouterInterface {
  _IsolatedRouterDelegate(this.container);

  final IsolatedContainer container;

  @override
  void addRoute(String method, String path, RequestHandler handler) {
    container.router.addRoute(method, path, handler);
  }

  @override
  void addIsolatedRouter(String prefix, RouterInterface router) {
    container.router.addIsolatedRouter(prefix, router);
  }

  @override
  RouteMatch? findRoute(String method, String path) {
    final delegateMatch = container.router.findRoute(method, path);
    if (delegateMatch == null) {
      return null;
    }

    return RouteMatch(
      (parentRequest, parentResponse) async {
        final scopedRequest = Request.from(
          parentRequest.httpRequest,
          container: container.container,
        );

        await container.processRequest(scopedRequest, parentResponse);
      },
      pathParams: delegateMatch.pathParams,
    );
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/services.dart
Size: 248 B
Code:
export 'package:http/http.dart' show MultipartFile;

export './base_container.dart';
export './controller.dart';
export './dart_express.dart';
export './dependency_injection.dart';
export './error_handler.dart';
export './isolated_container.dart';

-------- [ Separator ] ------

File Name: melos_dart_express.iml
Size: 762 B
Code:
<?xml version="1.0" encoding="UTF-8"?>
<module type="WEB_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/test" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/.dart_tool" />
      <excludeFolder url="file://$MODULE_DIR$/.pub" />
      <excludeFolder url="file://$MODULE_DIR$/build" />
    </content>
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="Dart SDK" level="project" />
    <orderEntry type="library" name="Dart Packages" level="project" />
  </component>
</module>
-------- [ Separator ] ------

File Name: pubspec.yaml
Size: 381 B
Code:
name: dart_express
description: A starting point for Dart libraries or applications.
version: 1.0.0
# repository: https://github.com/my_org/my_repo

environment:
  sdk: ^3.6.0

# Add regular dependencies here.
dependencies:
  args: ^2.4.2
  get_it: ^8.0.3
  http: ^1.2.2
  meta: ^1.16.0
  mime: ^2.0.0
  uri: ^1.0.0
  xml: ^6.5.0

dev_dependencies:
  lints: ^5.0.0
  test: ^1.24.0

-------- [ Separator ] ------

File Name: test/dart_express_test.dart
Size: 6.25 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

void main() {
  group('Application', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());

    tearDown(() async => harness.dispose());

    test('GET / returns 200 with correct body', () async {
      harness.app
          .get('/', (Request req, Response res) => res.text('Hello World!'));

      final response = await harness.get('/');

      expect(response.statusCode, 200);
      expect(response.body, 'Hello World!');
      expect(
          response.headers['set-cookie'], contains(Request.sessionCookieName));
    });

    test('POST / returns 201 with JSON response', () async {
      harness.app.post(
        '/',
        (Request req, Response res) =>
            res.json({'success': true}, statusCode: 201),
      );

      final response = await harness.post('/');

      expect(response.statusCode, 201);
      expect(response.headers['content-type'], 'application/json');
      expect(response.body, '{"success":true}');
    });

    test('Unknown route returns 404 with JSON payload', () async {
      final response = await harness.get('/not_found');

      expect(response.statusCode, 404);
      expect(response.headers['content-type'], 'application/json');
    });
    test('Reuses existing session cookie when provided', () async {
      final cookieHeader = '${Request.sessionCookieName}=existing-session';

      harness.app.get('/', (req, res) => res.text('OK'));

      final response = await harness.get(
        '/',
        headers: {HttpHeaders.cookieHeader: cookieHeader},
      );

      expect(response.statusCode, 200);
      // No duplicate cookie should be issued when already provided
      expect(response.headers['set-cookie'], isNull);
    });
  });

  group('Middleware', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Runs middleware in order', () async {
      final order = <int>[];

      harness.app.use((req, res, next) {
        order.add(1);
        return next();
      });

      harness.app.use((req, res, next) {
        order.add(2);
        return next();
      });

      harness.app.get('/middleware', (req, res) {
        order.add(3);
        res.text('OK');
      });

      final response = await harness.get('/middleware');

      expect(response.statusCode, 200);
      expect(order, [1, 2, 3]);
    });

    test('Middleware can modify response', () async {
      harness.app.use((req, res, next) {
        res.headers['X-Custom-Header'] = '123';
        return next();
      });

      harness.app.get('/header', (req, res) => res.text('OK'));

      final response = await harness.get('/header');

      expect(response.statusCode, 200);
      expect(response.headers['x-custom-header'], '123');
    });
  });

  group('Error Handling', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Unhandled error returns 500', () async {
      harness.app.get('/error', (req, res) => throw Exception('Test Error'));

      final response = await harness.get('/error');

      expect(response.statusCode, 500);
      expect(response.headers['content-type'], 'application/json');
    });
  });

  group('Route Parameters', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Parses route parameters', () async {
      harness.app.get('/users/:id', (req, res) {
        res.text('User ID: ${req.params['id']}');
      });

      final response = await harness.get('/users/123');

      expect(response.statusCode, 200);
      expect(response.body, 'User ID: 123');
    });
  });

  group('Isolated Container', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Routes and middleware execute in isolated scope', () async {
      final isolated = IsolatedContainer(prefix: '/island');
      isolated.use((req, res, next) {
        res.setHeader('X-Isolated', 'true');
        return next();
      });
      isolated.get('/', (req, res) => res.text('Isolated Root'));

      isolated.mount(harness.app);

      final response = await harness.get('/island');

      expect(response.statusCode, 200);
      expect(response.body, 'Isolated Root');
      expect(response.headers['x-isolated'], 'true');
    });

    test('Uses independent dependency injection scope', () async {
      final isolated = IsolatedContainer(prefix: '/island');

      harness.app.inject<Dependency>(Dependency('parent'));
      isolated.inject<Dependency>(Dependency('isolated'));

      isolated.get('/value', (req, res) {
        final dep = req.container.get<Dependency>();
        res.json({'value': dep.id});
      });

      isolated.mount(harness.app);

      final response = await harness.get('/island/value');

      expect(response.statusCode, 200);
      expect(response.body, '{"value":"isolated"}');

      final parentResponse = await harness.get('/missing');
      expect(parentResponse.statusCode, 404);
    });
  });
}

class TestServerHarness {
  final DartExpress app = DartExpress();
  HttpServer? _server;

  Future<http.Response> get(String path, {Map<String, String>? headers}) async {
    await _ensureServer();
    return http.get(_uri(path), headers: headers);
  }

  Future<http.Response> post(String path,
      {Object? body, Map<String, String>? headers}) async {
    await _ensureServer();
    return http.post(_uri(path), body: body, headers: headers);
  }

  Future<void> dispose() async {
    if (_server != null) {
      await _server!.close(force: true);
      await app.waitUntilClosed(_server!);
      _server = null;
    } else {
      await app.onDispose();
    }
  }

  Future<void> _ensureServer() async {
    if (_server != null) {
      return;
    }

    _server = await app.listen(0, address: InternetAddress.loopbackIPv4);
  }

  Uri _uri(String path) {
    final normalized = path.startsWith('/') ? path : '/$path';
    return Uri.parse('http://localhost:${_server!.port}$normalized');
  }
}

class Dependency {
  Dependency(this.id);
  final String id;
}

-------- [ Separator ] ------
