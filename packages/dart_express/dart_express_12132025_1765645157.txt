Project Overview
===============

Project Statistics:
Total Files: 49
Total Size: 143.78 KB

File Types:
  .dart: 39 files
  .md: 3 files
  .yaml: 2 files
  .json: 1 files
  no extension: 1 files
  .iml: 1 files
  .txt: 1 files
  .js: 1 files

Detected Technologies:

Folder Structure (Tree)
=====================
Legend: ✓ = Included in output, ✗ = Excluded from output

├── .claude/
│   └── settings.local.json (138 B) ✓
├── .dart_tool/
├── .gitignore (221 B) ✓
├── CHANGELOG.md (29 B) ✓
├── README.md (4.14 KB) ✓
├── analysis_options.yaml (1.01 KB) ✓
├── docs/
│   └── testing_status.md (1.33 KB) ✓
├── example/
│   └── dart_express_example.dart (2.33 KB) ✓
├── lib/
│   ├── dart_express.dart (253 B) ✓
│   └── src/
│       ├── dart_express_base.dart (162 B) ✓
│       ├── extensions.dart (698 B) ✓
│       ├── middleware/
│       │   └── cookies_parser.dart (1.46 KB) ✓
│       ├── models/
│       │   ├── memory_session_store.dart (3.55 KB) ✓
│       │   ├── memory_store.dart (1.98 KB) ✓
│       │   ├── middleware.dart (860 B) ✓
│       │   ├── models.dart (210 B) ✓
│       │   ├── request.dart (12.86 KB) ✓
│       │   ├── response.dart (5.19 KB) ✓
│       │   ├── session_signer.dart (2.05 KB) ✓
│       │   └── session_store.dart (3.92 KB) ✓
│       ├── router/
│       │   ├── listRouter/
│       │   │   ├── listRouter.dart (27 B) ✓
│       │   │   ├── list_router.dart (1.40 KB) ✓
│       │   │   └── route_entry.dart (1.86 KB) ✓
│       │   ├── radixRouter/
│       │   │   ├── radixRouter.dart (28 B) ✓
│       │   │   ├── radix_node.dart (1.47 KB) ✓
│       │   │   └── radix_router.dart (5.26 KB) ✓
│       │   ├── router.dart (76 B) ✓
│       │   └── router_interface.dart (949 B) ✓
│       └── services/
│           ├── base_container.dart (8.31 KB) ✓
│           ├── controller.dart (2.32 KB) ✓
│           ├── dart_express.dart (14.41 KB) ✓
│           ├── dependency_injection.dart (604 B) ✓
│           ├── error_handler.dart (1018 B) ✓
│           ├── isolated_container.dart (5.42 KB) ✓
│           └── services.dart (248 B) ✓
├── melos_dart_express.iml (762 B) ✓
├── pubspec.yaml (447 B) ✓
├── test/
│   ├── dart_express_test.dart (6.25 KB) ✓
│   ├── helpers/
│   │   └── test_server_harness.dart (3.06 KB) ✓
│   ├── integration/
│   │   └── server_lifecycle_test.dart (1.81 KB) ✓
│   ├── performance/
│   │   └── concurrency_test.dart (1.12 KB) ✓
│   ├── security/
│   │   └── security_test.dart (2.24 KB) ✓
│   ├── test_12052025_1764904625.txt (27.06 KB) ✓
│   └── unit/
│       ├── config_test.dart (519 B) ✓
│       ├── middleware_test.dart (3.15 KB) ✓
│       ├── request_test.dart (6.50 KB) ✓
│       └── router_test.dart (1.94 KB) ✓
└── tool/
    ├── benchmark.dart (845 B) ✓
    ├── serve_multi.dart (913 B) ✓
    └── serve_multi.k6.js (1.59 KB) ✓

==============

File Name: .claude/settings.local.json
Size: 138 B
Code:
{
  "permissions": {
    "allow": [
      "Bash(dart pub get:*)",
      "Bash(dart analyze:*)"
    ],
    "deny": [],
    "ask": []
  }
}

-------- [ Separator ] ------

File Name: .gitignore
Size: 221 B
Code:
# https://dart.dev/guides/libraries/private-files
# Created by `dart pub`
.dart_tool/

# Avoid committing pubspec.lock for library packages; see
# https://dart.dev/guides/libraries/private-files#pubspeclock.
pubspec.lock

-------- [ Separator ] ------

File Name: CHANGELOG.md
Size: 29 B
Code:
## 1.0.0

- Initial version.

-------- [ Separator ] ------

File Name: README.md
Size: 4.14 KB
Code:
# dart_express

An Express-inspired HTTP framework for Dart. It brings familiar routing,
middleware, and dependency-injection patterns to `dart:io` while remaining
lightweight and dependency-free beyond `GetIt`.

## Features

- Fast radix-tree router with support for path parameters and nested routers
- Middleware pipeline with global and per-route handlers
- `GetIt`-powered dependency injection (supports async/lazy registrations)
- Controller abstraction for modular route registration
- Optional isolated containers for mounting self-contained sub-apps
- Batteries-included middleware for CORS, rate limiting, and cookie parsing

## Quick start

```bash
dart pub add dart_express
```

```dart
import 'dart:io';

import 'package:dart_express/dart_express.dart';

Future<void> main() async {
  final app = DartExpress();

  app.use(app.cors(allowedOrigins: ['http://localhost:3000']));
  app.get('/health', (req, res) => res.text('OK'));

  final port = int.parse(Platform.environment['PORT'] ?? '8080');
  await app.listen(port);
  print('Listening on http://localhost:$port');
}
```

## Routing essentials

- Use `app.get`, `app.post`, etc. to register handlers. Supply optional
  middleware with the `middleware:` argument.
- Controllers help organise routes:

  ```dart
  class UsersController extends Controller {
    @override
    void registerRoutes(ControllerOptions options) {
      options.get('/', _list);
      options.get('/:id(\\d+)', _show);
    }
  }

  app.useController('/users', UsersController());
  ```

- Throw one of the built-in `HttpError` types (`NotFoundError`,
  `ValidationError`, etc.) to short-circuit with a specific status code.

## Working with dependencies

The container is backed by `GetIt`. Register dependencies during startup and
retrieve them in handlers via `request.container`:

```dart
app.registerLazySingleton(() => Database(config));

app.get('/posts', (req, res) async {
  final db = req.container.get<Database>();
  final posts = await db.posts();
  res.json({'data': posts});
});
```

## Isolated modules

`IsolatedContainer` lets you mount a self-contained sub-application that has its
own middleware, router, and DI scope while sharing the main server:

```dart
final admin = IsolatedContainer(prefix: '/admin');
admin.use((req, res, next) {
  res.setHeader('X-Isolated', 'admin');
  return next();
});
admin.get('/', (req, res) => res.text('Admin dashboard'));
admin.mount(app);
```

For integration testing or microservice setups you can host the isolated module
by itself:

```dart
await admin.listen(9090); // optional
```

## Example project

See [`example/dart_express_example.dart`](example/dart_express_example.dart) for
a full reference that demonstrates controllers, isolated modules, and common
middleware.

## Error handling

Install a global error handler to customise responses:

```dart
app.setErrorHandler((error, req, res) async {
  if (error is ValidationError) {
    res.json({'error': error.message, 'details': error.data},
        statusCode: error.statusCode);
    return;
  }

  res.setStatus(HttpStatus.internalServerError);
  res.json({'error': 'Internal Server Error'});
});
```

## Performance tips

- Deploy behind a reverse proxy (nginx, Caddy) that terminates TLS and handles
  static assets.
- Reuse the same `DartExpress` instance across isolates if you need more CPU
  headroom—each isolate can call `await app.listen(port, address: ...)` with a
  different binding.
- For load testing use tools like [`wrk`](https://github.com/wg/wrk) or
  [`hey`](https://github.com/rakyll/hey)`:

  ```bash
  wrk -t8 -c256 -d30s http://localhost:8080/health
  ```

  Test both direct routes and isolated modules to compare overhead.
- Request parsing currently buffers the entire body; set upstream limits (e.g.
  via load balancer) and prefer streaming uploads for very large payloads.

Or use the built-in helper:

```bash
dart run tool/bench.dart --url http://localhost:8080/health --count 1000 --concurrency 32
```

## Contributing

- Run `dart format .` and `dart analyze` before submitting patches.
- Add regression tests under `test/` for routing/middleware changes.
- File issues or feature requests in the repository issue tracker.

## License

MIT License.

-------- [ Separator ] ------

File Name: analysis_options.yaml
Size: 1.01 KB
Code:
# This file configures the static analysis results for your project (errors,
# warnings, and lints).
#
# This enables the 'recommended' set of lints from `package:lints`.
# This set helps identify many issues that may lead to problems when running
# or consuming Dart code, and enforces writing Dart using a single, idiomatic
# style and format.
#
# If you want a smaller set of lints you can change this to specify
# 'package:lints/core.yaml'. These are just the most critical lints
# (the recommended set includes the core lints).
# The core lints are also what is used by pub.dev for scoring packages.

include: package:lints/recommended.yaml

# Uncomment the following section to specify additional rules.

# linter:
#   rules:
#     - camel_case_types

# analyzer:
#   exclude:
#     - path/to/excluded/files/**

# For more information about the core and recommended set of lints, see
# https://dart.dev/go/core-lints

# For additional information about configuring this file, see
# https://dart.dev/guides/language/analysis-options

-------- [ Separator ] ------

File Name: docs/testing_status.md
Size: 1.33 KB
Code:
# Testing Status

## Runs Performed
- `dart test test/unit/request_test.dart -p vm` — **pass**.
- `dart test test/integration/server_lifecycle_test.dart -p vm` — **pass**.
- Full-suite `dart test` — **pass** (logs include expected HttpError printouts when tests trigger error paths).

## Fixes Completed
- **Request body size limit**: rewrote `_ensureBodyBytes` to use `StreamIterator`, discard remaining bytes on overflow without double-listening, and surface a clean 413.
- **Multipart parsing**: tightened `_FormDataPayload` typing/copying to avoid `List<dynamic>` casts and ensured file-size violations raise controlled HttpErrors.
- **Shutdown handling**: `DartExpress.close` now waits on server lifecycles and adds a brief grace window so late requests get 503s instead of connection refusals.
- **Tracing/logging**: Request IDs are accepted/generated and echoed on responses; errors are logged via `logger`. CORS now rejects wildcard+credentials combos.
- **Config safety**: constructor validates limits/timeouts and warns when `maxFileSize > maxBodySize`.
- **Tooling**: Added `tool/benchmark.dart` for quick local load tests.

## Current Status
- All authored suites (unit, integration, security, performance) are green via `dart test`.
- Remaining console noise is from tests intentionally provoking 4xx/5xx paths; behaviour matches expectations.

-------- [ Separator ] ------

File Name: example/dart_express_example.dart
Size: 2.33 KB
Code:
import 'dart:async';
import 'dart:io';

import 'package:dart_express/dart_express.dart';

Future<void> main() async {
  final app = DartExpress();

  // Register shared dependencies.
  app.inject<Clock>(SystemClock());

  // Global middleware.
  app.use(app.cors(allowedOrigins: ['http://localhost:3000']));
  app.use(
      app.rateLimiter(maxRequests: 200, window: const Duration(minutes: 1)));
  app.setErrorHandler((err, req, res) {
    print(err);
    res.json({'error': err.toString()}, statusCode: 500);
  });
  // Simple health endpoint.
  app.get('/health', (req, res) {
    res.json({'status': 'ok', 'timestamp': req.container.get<Clock>().now()});
  });

  // Echo JSON payloads back to the client.
  app.post('/echo', (req, res) async {
    final payload = await req.body;
    res.json({'received': payload});
  });

  // Mount a controller for user routes.
  app.useController('/users', UsersController());

  // Mount an isolated admin module.
  final admin = IsolatedContainer(prefix: '/admin');
  admin.use((req, res, next) {
    res.setHeader('X-Isolated', 'admin');
    return next();
  });
  admin.get('/', (req, res) => res.text('Welcome to the admin module'));
  admin.get('/stats', (req, res) async {
    res.json({'uptimeSeconds': ProcessInfo.currentRss});
  });
  admin.mount(app);

  final port = int.parse(Platform.environment['PORT'] ?? '8080');
  await app.listen(port);
  print('dart_express example running on http://localhost:$port');
}

class UsersController extends Controller {
  static final List<Map<String, dynamic>> _users = [
    {'id': 1, 'name': 'Ada'},
    {'id': 2, 'name': 'Linus'},
  ];

  @override
  void registerRoutes(ControllerOptions options) {
    options.get('/', _listUsers);
    options.get('/:id(\\d+)', _getUserById);
  }

  Future<void> _listUsers(Request request, Response response) async {
    response.json({'data': _users});
  }

  Future<void> _getUserById(Request request, Response response) async {
    final id = int.tryParse(request.params['id'] ?? '');
    final user =
        _users.firstWhere((entry) => entry['id'] == id, orElse: () => {});

    if (user.isEmpty) {
      throw NotFoundError('User $id not found');
    }

    response.json({'data': user});
  }
}

abstract class Clock {
  String now();
}

class SystemClock implements Clock {
  @override
  String now() => DateTime.now().toUtc().toIso8601String();
}

-------- [ Separator ] ------

File Name: lib/dart_express.dart
Size: 253 B
Code:
/// Support for doing something awesome.
///
/// More dartdocs go here.
library;

export 'src/models/models.dart';
export 'src/services/services.dart';
export 'src/router/router.dart';
// TODO: Export any libraries intended for clients of this package.

-------- [ Separator ] ------

File Name: lib/src/dart_express_base.dart
Size: 162 B
Code:
// // TODO: Put public facing types in this file.
//
// /// Checks if you are awesome. Spoiler: you are.
// class Awesome {
//   bool get isAwesome => true;
// }

-------- [ Separator ] ------

File Name: lib/src/extensions.dart
Size: 698 B
Code:
extension ListContains<T> on List<T> {
  void replaceWhere(bool Function(T element) test, T newElement) {
    for (var i = 0; i < length; i++) {
      if (test(this[i])) {
        this[i] = newElement;
      }
    }
  }

  int? containsWithId(
    bool Function(T element) test,
  ) {
    for (var element in this) {
      if (test(element)) return indexOf(element);
    }
    return null;
  }

  T? containsWithCondition(
    bool Function(T element) test,
  ) {
    for (var element in this) {
      if (test(element)) return element;
    }
    return null;
  }

  bool hasIndex(int index) {
    if (length == 0 || index < 0 || index >= length) {
      return false;
    }
    return true;
  }
}

-------- [ Separator ] ------

File Name: lib/src/middleware/cookies_parser.dart
Size: 1.46 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';

class CookieParser {
  static MiddlewareHandler middleware({
    bool decodeValues = true,
    bool allowEmptyValues = false,
  }) {
    return (Request req, Response res, NextFunction next) async {
      try {
        req.cookies = _parseCookies(
          req.headers.value(HttpHeaders.cookieHeader),
          decodeValues: decodeValues,
          allowEmptyValues: allowEmptyValues,
        );
        await next();
      } catch (e) {
        await next(); // Could throw error if desired
      }
    };
  }

  static List<Cookie> _parseCookies(
    String? cookieHeader, {
    required bool decodeValues,
    required bool allowEmptyValues,
  }) {
    final cookies = <Cookie>[];
    if (cookieHeader == null || cookieHeader.isEmpty) {
      return cookies;
    }

    final pairs = cookieHeader.split(RegExp(r';\s*'));
    for (final pair in pairs) {
      if (pair.isEmpty) continue;

      final parts = pair.split('=');
      if (parts.isEmpty) continue;

      final name = parts[0].trim();
      if (name.isEmpty) continue;

      String value = parts.length > 1 ? parts.sublist(1).join('=').trim() : '';

      if (!allowEmptyValues && value.isEmpty) continue;

      if (decodeValues) {
        try {
          value = Uri.decodeComponent(value);
        } catch (e) {
          continue;
        }
      }

      final cookie = Cookie(name, value);
      cookies.add(cookie);
    }

    return cookies;
  }
}

-------- [ Separator ] ------

File Name: lib/src/models/memory_session_store.dart
Size: 3.55 KB
Code:
import 'dart:async';
import 'package:dart_express/src/models/session_store.dart';

/// In-memory session store implementation.
///
/// **WARNING**: This store is NOT suitable for production deployments with
/// multiple server instances. Sessions are:
/// - Lost on server restart
/// - Not shared across instances
/// - Limited by available RAM
///
/// **Use Cases**:
/// - Development and testing
/// - Single-instance deployments
/// - Prototyping
///
/// **Production Alternative**:
/// Use a distributed store like Redis, PostgreSQL, or MongoDB for
/// production multi-instance deployments.
///
/// ## Features
/// - Automatic session expiration with configurable TTL
/// - Periodic cleanup of expired sessions
/// - Thread-safe operations
/// - Memory-efficient with automatic pruning
///
/// ## Example
/// ```dart
/// final store = MemorySessionStore(
///   defaultTTL: Duration(hours: 24),
///   cleanupInterval: Duration(minutes: 15),
/// );
///
/// final app = DartExpress(sessionStore: store);
/// ```
class MemorySessionStore implements SessionStore {
  final Map<String, _SessionEntry> _sessions = {};
  final Duration defaultTTL;
  final Duration _cleanupInterval;
  Timer? _cleanupTimer;

  /// Creates a memory-backed session store.
  ///
  /// Parameters:
  /// - [defaultTTL]: Default session lifetime (default: 24 hours)
  /// - [cleanupInterval]: How often to clean expired sessions (default: 10 minutes)
  MemorySessionStore({
    this.defaultTTL = const Duration(hours: 24),
    Duration cleanupInterval = const Duration(minutes: 10),
  }) : _cleanupInterval = cleanupInterval {
    _startCleanup();
  }

  @override
  Future<Map<String, dynamic>?> load(String sessionId) async {
    final entry = _sessions[sessionId];

    // Check if session exists and is not expired
    if (entry == null || entry.isExpired) {
      if (entry != null) {
        _sessions.remove(sessionId); // Clean up expired session
      }
      return null;
    }

    // Return a copy of the data to prevent external modifications
    return Map<String, dynamic>.from(entry.data);
  }

  @override
  Future<void> save(
    String sessionId,
    Map<String, dynamic> data, {
    Duration? ttl,
  }) async {
    final expiresAt = DateTime.now().add(ttl ?? defaultTTL);

    _sessions[sessionId] = _SessionEntry(
      data: Map<String, dynamic>.from(data), // Store a copy
      expiresAt: expiresAt,
    );
  }

  @override
  Future<void> destroy(String sessionId) async {
    _sessions.remove(sessionId);
  }

  @override
  Future<void> touch(String sessionId, {Duration? ttl}) async {
    final entry = _sessions[sessionId];
    if (entry != null && !entry.isExpired) {
      entry.expiresAt = DateTime.now().add(ttl ?? defaultTTL);
    }
  }

  @override
  Future<void> cleanup() async {
    _sessions.removeWhere((_, entry) => entry.isExpired);
  }

  @override
  Future<void> dispose() async {
    _cleanupTimer?.cancel();
    _sessions.clear();
  }

  void _startCleanup() {
    _cleanupTimer = Timer.periodic(_cleanupInterval, (_) {
      cleanup();
    });
  }

  /// Returns the number of active sessions (for monitoring/debugging).
  int get sessionCount => _sessions.length;

  /// Returns the number of expired sessions awaiting cleanup.
  int get expiredSessionCount {
    return _sessions.values.where((entry) => entry.isExpired).length;
  }
}

/// Internal session entry with expiration tracking.
class _SessionEntry {
  final Map<String, dynamic> data;
  DateTime expiresAt;

  _SessionEntry({
    required this.data,
    required this.expiresAt,
  });

  bool get isExpired => DateTime.now().isAfter(expiresAt);
}

-------- [ Separator ] ------

File Name: lib/src/models/memory_store.dart
Size: 1.98 KB
Code:
import 'dart:async';
import 'dart:collection';

abstract class RateLimitStore {
  Future<bool> increment(String key, int maxRequests, Duration window);
  Future<void> reset(String key);
}

/// In-memory store for rate limiter with automatic cleanup
class MemoryRateLimitStore implements RateLimitStore {
  final HashMap<String, List<int>> _store = HashMap();
  final HashMap<String, int> _lastAccess = HashMap();
  Timer? _cleanupTimer;
  final Duration _cleanupInterval;
  final Duration _keyExpiry;

  MemoryRateLimitStore({
    Duration cleanupInterval = const Duration(minutes: 10),
    Duration keyExpiry = const Duration(hours: 1),
  })  : _cleanupInterval = cleanupInterval,
        _keyExpiry = keyExpiry {
    _startCleanup();
  }

  void _startCleanup() {
    _cleanupTimer = Timer.periodic(_cleanupInterval, (_) => _cleanup());
  }

  void _cleanup() {
    final now = DateTime.now().millisecondsSinceEpoch;
    final expiryThreshold = now - _keyExpiry.inMilliseconds;
    final keysToRemove = <String>[];

    for (final entry in _lastAccess.entries) {
      if (entry.value < expiryThreshold) {
        keysToRemove.add(entry.key);
      }
    }

    for (final key in keysToRemove) {
      _store.remove(key);
      _lastAccess.remove(key);
    }
  }

  @override
  Future<bool> increment(String key, int maxRequests, Duration window) async {
    final now = DateTime.now().millisecondsSinceEpoch;
    final windowStart = now - window.inMilliseconds;

    _lastAccess[key] = now; // Track last access for cleanup

    _store.putIfAbsent(key, () => []);

    _store[key]!.removeWhere((timestamp) => timestamp < windowStart);

    if (_store[key]!.length >= maxRequests) {
      return false; // Rate limit exceeded
    }

    _store[key]!.add(now);
    return true;
  }

  @override
  Future<void> reset(String key) async {
    if (_store.containsKey(key)) {
      _store.remove(key);
      _lastAccess.remove(key);
    }
  }

  /// Dispose the cleanup timer
  void dispose() {
    _cleanupTimer?.cancel();
  }
}

-------- [ Separator ] ------

File Name: lib/src/models/middleware.dart
Size: 860 B
Code:
import 'dart:async';

import 'request.dart';
import 'response.dart';

/// Continuation invoked by middleware to advance the pipeline.
typedef NextFunction = FutureOr<void> Function();

/// Signature for middleware functions that can perform asynchronous work.
typedef MiddlewareFunction = Future<void> Function(
    Request request, Response response, NextFunction next);

/// Signature for route handlers.
typedef RequestHandler = FutureOr<void> Function(
    Request request, Response response);

/// Alias used across the framework for middleware registration.
typedef MiddlewareHandler = FutureOr<void> Function(
    Request request, Response response, NextFunction next);

/// Wrapper describing a middleware bound to a specific [path].
class Middleware {
  final String path;
  final MiddlewareFunction handler;

  Middleware(this.path, this.handler);
}

-------- [ Separator ] ------

File Name: lib/src/models/models.dart
Size: 210 B
Code:
export './memory_store.dart';
export './memory_session_store.dart';
export './middleware.dart';
export './request.dart';
export './response.dart';
export './session_signer.dart';
export './session_store.dart';

-------- [ Separator ] ------

File Name: lib/src/models/request.dart
Size: 12.86 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:dart_express/dart_express.dart';
import 'package:get_it/get_it.dart';
import 'package:mime/mime.dart';
import 'package:uuid/uuid.dart';

/// Represents an incoming HTTP request flowing through the framework.
///
/// Exposes helpers for accessing parsed payloads, form data, uploaded files
/// and dependency-injected services while ensuring the underlying stream is
/// consumed exactly once.
class Request {
  final HttpRequest httpRequest;
  final String requestId;
  Map<String, String> params = {};
  late final Map<String, String> query;
  final Session session;
  final GetIt container;
  final int maxBodySize;
  final int maxFileSize;
  final SessionSigner? sessionSigner;
  Object? _parsedBody;
  Future<Uint8List>? _bodyBytesFuture;
  _FormDataPayload? _multipartPayload;
  Map<String, dynamic>? _formDataCache;
  final bool _isSessionNew;
  List<Cookie> cookies = [];

  Request(
    this.httpRequest,
    this.session,
    this.requestId,
    this.container, {
    bool isSessionNew = false,
    this.maxBodySize = 10 * 1024 * 1024,
    this.maxFileSize = 100 * 1024 * 1024,
    this.sessionSigner,
  }) : _isSessionNew = isSessionNew {
    query = httpRequest.uri.queryParameters;
  }

  String get method => httpRequest.method;
  Uri get uri => httpRequest.uri;
  HttpHeaders get headers => httpRequest.headers;

  /// Returns the parsed request body.
  ///
  /// * JSON payloads are decoded via `jsonDecode`
  /// * `application/x-www-form-urlencoded` payloads return a map of fields
  /// * Text payloads resolve to a `String`
  /// * All other content types yield the raw `Uint8List`
  Future<Object?> get body async {
    if (_parsedBody != null) {
      return _parsedBody;
    }

    final contentType = headers.contentType?.mimeType ?? '';
    final bodyBytes = await _ensureBodyBytes();

    if (bodyBytes.isEmpty) {
      _parsedBody = null;
      return _parsedBody;
    }

    if (contentType == ContentType.json.mimeType ||
        contentType.endsWith('+json')) {
      _parsedBody = jsonDecode(utf8.decode(bodyBytes));
      return _parsedBody;
    }

    if (contentType == 'application/x-www-form-urlencoded') {
      _parsedBody = Uri.splitQueryString(utf8.decode(bodyBytes));
      return _parsedBody;
    }

    if (contentType.startsWith('text/')) {
      _parsedBody = utf8.decode(bodyBytes);
      return _parsedBody;
    }

    _parsedBody = bodyBytes;
    return _parsedBody;
  }

  /// Returns a merged view of multipart form fields and uploaded files.
  ///
  /// Keys pointing to files expose `List<MultipartFile>` while standard
  /// fields expose `String` values. For non-multipart requests this resolves
  /// to an empty map.
  Future<Map<String, dynamic>> get formData async {
    if (_formDataCache != null) {
      return _formDataCache!;
    }

    final payload = await _ensureMultipartPayload();
    final combined = <String, dynamic>{};
    combined.addAll(payload.fields);
    combined.addAll(payload.files);
    _formDataCache = Map.unmodifiable(combined);
    return _formDataCache!;
  }

  /// Creates a request wrapper, bootstrapping session state from the incoming
  /// cookie (or generating a new session identifier when absent).
  ///
  /// If [sessionSigner] is provided, session cookies will be verified using
  /// HMAC-SHA256. Invalid signatures will be treated as if no session exists.
  factory Request.from(
    HttpRequest httpRequest, {
    required GetIt container,
    int maxBodySize = 10 * 1024 * 1024,
    int maxFileSize = 100 * 1024 * 1024,
    SessionSigner? sessionSigner,
    SessionStore? sessionStore,
  }) {
    Cookie? sessionCookie;
    bool isSessionNew = false;
    String sessionId;

    try {
      sessionCookie = httpRequest.cookies
          .firstWhere((cookie) => cookie.name == _sessionCookieName);

      // Verify signed session cookie if signer is available
      if (sessionSigner != null) {
        final verifiedId = sessionSigner.verify(sessionCookie.value);
        if (verifiedId != null) {
          sessionId = verifiedId;
        } else {
          // Invalid signature - generate new session
          sessionId = _generateSessionId();
          isSessionNew = true;
        }
      } else {
        // No signing - use cookie value as-is
        sessionId = sessionCookie.value;
      }
    } on StateError {
      // No session cookie found - create new session
      sessionId = _generateSessionId();
      isSessionNew = true;
    }

    final session = Session(sessionId, store: sessionStore);
    final requestId = httpRequest.headers.value('x-request-id') ??
        httpRequest.headers.value('x-correlation-id') ??
        _generateRequestId();

    return Request(
      httpRequest,
      session,
      requestId,
      container,
      isSessionNew: isSessionNew,
      maxBodySize: maxBodySize,
      maxFileSize: maxFileSize,
      sessionSigner: sessionSigner,
    );
  }

  /// Generate a cryptographically secure session ID using UUID v4
  static String _generateSessionId() {
    return const Uuid().v4();
  }

  static String _generateRequestId() {
    return const Uuid().v4();
  }

  /// Indicates whether a fresh session identifier was generated for this
  /// request (and therefore needs to be persisted back via response cookies).
  bool get isNewSession => _isSessionNew;

  Future<Map<String, List<MultipartFile>>> get files async {
    final payload = await _ensureMultipartPayload();
    return payload.files;
  }

  // Helper method to read stream fully into a list of bytes to prevent multiple listens
  Future<List<int>> consolidateBytes(Stream<List<int>> stream,
      {int? sizeLimit}) async {
    final buffer = BytesBuilder();
    var totalSize = 0;
    final limit = sizeLimit ?? maxFileSize;

    await for (final chunk in stream) {
      totalSize += chunk.length;

      if (totalSize > limit) {
        throw HttpError(413, 'File too large');
      }

      buffer.add(chunk);
    }
    return buffer.takeBytes();
  }

  Future<Uint8List> _ensureBodyBytes() {
    final existing = _bodyBytesFuture;
    if (existing != null) {
      return existing;
    }

    final future = () async {
      final buffer = BytesBuilder();
      var totalSize = 0;
      final iterator = StreamIterator<List<int>>(httpRequest);

      try {
        while (await iterator.moveNext()) {
          final chunk = iterator.current;
          totalSize += chunk.length;

          if (totalSize > maxBodySize) {
            // Consume and discard remaining bytes to keep the socket healthy.
            while (await iterator.moveNext()) {}
            throw HttpError(413, 'Payload Too Large');
          }

          buffer.add(chunk);
        }
      } finally {
        await iterator.cancel();
      }

      return buffer.takeBytes();
    }();

    _bodyBytesFuture = future;
    return future;
  }

  Future<_FormDataPayload> _ensureMultipartPayload() async {
    if (_multipartPayload != null) {
      return _multipartPayload!;
    }

    final contentType = headers.contentType;
    if (contentType?.mimeType != 'multipart/form-data') {
      _multipartPayload = _FormDataPayload.empty;
      _formDataCache = const {};
      return _multipartPayload!;
    }

    final boundary = contentType!.parameters['boundary'];
    if (boundary == null || boundary.isEmpty) {
      _multipartPayload = _FormDataPayload.empty;
      _formDataCache = const {};
      return _multipartPayload!;
    }

    final transformer = MimeMultipartTransformer(boundary);
    final bodyBytes = await _ensureBodyBytes();
    final stream = Stream<List<int>>.fromIterable(<List<int>>[bodyBytes]);
    final parts = await transformer.bind(stream).toList();

    final fieldData = <String, String>{};
    final fileData = <String, List<MultipartFile>>{};

    for (final part in parts) {
      final contentDisposition = part.headers['content-disposition'];
      if (contentDisposition == null) {
        continue;
      }

      final nameMatch =
          RegExp(r'name="([^"]*)"').firstMatch(contentDisposition);
      if (nameMatch == null) {
        continue;
      }

      final name = nameMatch.group(1)!;
      final filenameMatch =
          RegExp(r'filename="([^"]*)"').firstMatch(contentDisposition);

      if (filenameMatch != null) {
        // This is a file upload - check file size limit
        final filename = filenameMatch.group(1)!;
        final bytes = Uint8List.fromList(
            await consolidateBytes(part, sizeLimit: maxFileSize));

        final filesForField =
            fileData.putIfAbsent(name, () => <MultipartFile>[]);
        filesForField.add(
          MultipartFile.fromBytes(
            name,
            bytes,
            filename: filename,
          ),
        );
      } else {
        // Regular form field
        final bytes = Uint8List.fromList(await consolidateBytes(part));
        fieldData[name] = utf8.decode(bytes);
      }
    }

    _multipartPayload = _FormDataPayload(fieldData, fileData);
    final combined = <String, dynamic>{};
    combined.addAll(_multipartPayload!.fields);
    combined.addAll(_multipartPayload!.files);
    _formDataCache = Map.unmodifiable(combined);
    return _multipartPayload!;
  }

  static const String _sessionCookieName = 'sessionId';

  /// Public accessor for the name of the framework-managed session cookie.
  static const String sessionCookieName = _sessionCookieName;
}

/// Represents a user session with optional persistent storage.
///
/// Sessions can be backed by a [SessionStore] for persistence across
/// server restarts and multi-instance deployments.
///
/// ## Usage
/// ```dart
/// // Access session data
/// final userId = req.session['userId'];
///
/// // Set session data
/// req.session['userId'] = '123';
/// req.session['username'] = 'john';
///
/// // Session is automatically saved after request completes
/// ```
class Session {
  final String id;
  final SessionStore? _store;
  Map<String, dynamic> _data = {};
  bool _isDirty = false;
  bool _isLoaded = false;

  Session(this.id, {SessionStore? store}) : _store = store {
    // If no store, mark as loaded since there's nothing to load
    if (store == null) {
      _isLoaded = true;
    }
  }

  /// Gets a value from the session.
  dynamic operator [](String key) => _data[key];

  /// Sets a value in the session and marks it as dirty.
  void operator []=(String key, dynamic value) {
    _data[key] = value;
    _isDirty = true;
  }

  /// Removes a key from the session.
  void remove(String key) {
    _data.remove(key);
    _isDirty = true;
  }

  /// Clears all session data.
  void clear() {
    _data.clear();
    _isDirty = true;
  }

  /// Returns an unmodifiable view of session data.
  Map<String, dynamic> get data => Map.unmodifiable(_data);

  /// Whether this session has unsaved changes.
  bool get isDirty => _isDirty;

  /// Loads session data from the store.
  ///
  /// This is automatically called when a request is processed.
  /// You rarely need to call this manually.
  Future<void> load() async {
    if (_store != null && !_isLoaded) {
      final loadedData = await _store.load(id);
      _data = loadedData ?? {};
      _isLoaded = true;
      _isDirty = false;
    }
  }

  /// Saves session data to the store if it has been modified.
  ///
  /// This is automatically called after a request completes.
  /// You can call it manually if you need to ensure data is persisted.
  ///
  /// Parameters:
  /// - [ttl]: Optional time-to-live for the session
  Future<void> save({Duration? ttl}) async {
    if (_store != null && _isDirty) {
      await _store.save(id, _data, ttl: ttl);
      _isDirty = false;
    }
  }

  /// Destroys this session, removing all data from the store.
  ///
  /// After calling this, the session ID becomes invalid and a new
  /// session will be created on the next request.
  Future<void> destroy() async {
    if (_store != null) {
      await _store.destroy(id);
    }
    _data.clear();
    _isDirty = false;
  }

  // Removed regenerate() method - session ID is final and can't be changed.
  // To regenerate session for security (e.g., after login), create a new
  // session by destroying the current one and letting the framework create
  // a new one on the next request.
  //
  // Example:
  //   await req.session.destroy();
  //   res.clearCookie(Request.sessionCookieName);
  //   // Next request will get a new session
}

class _FormDataPayload {
  _FormDataPayload(
      Map<String, String> fields, Map<String, List<MultipartFile>> files)
      : fields = Map.unmodifiable(Map<String, String>.from(fields)),
        files = Map.unmodifiable(
          files.map(
            (key, value) =>
                MapEntry(key, List<MultipartFile>.unmodifiable(value)),
          ),
        );

  static final _FormDataPayload empty =
      _FormDataPayload(<String, String>{}, <String, List<MultipartFile>>{});

  final Map<String, String> fields;
  final Map<String, List<MultipartFile>> files;

  bool get hasFiles => files.isNotEmpty;
  bool get isEmpty => fields.isEmpty && files.isEmpty;
}

-------- [ Separator ] ------

File Name: lib/src/models/response.dart
Size: 5.19 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:mime/mime.dart';

/// Represents an outgoing HTTP response with helpers for composing common
/// payload types and managing headers/cookies before the underlying
/// [HttpResponse] is closed.
class Response {
  int statusCode;
  dynamic body;
  Map<String, String> headers = {};
  bool isBinary = false;
  bool _isSent = false;
  final List<Cookie> _cookies = [];
  bool get isSent => _isSent;

  Response({this.statusCode = 200, this.body, Map<String, String>? headers}) {
    if (headers != null) {
      this.headers.addAll(headers);
    }
  }

  /// Adds or replaces a cookie on the response. Existing cookies with the same
  /// name and path are overwritten to avoid duplicate `Set-Cookie` headers.
  void cookie(
    String name,
    String value, {
    DateTime? expires,
    int? maxAge,
    String? domain,
    String? path,
    bool secure = true,
    bool httpOnly = true,
    SameSite? sameSite = SameSite.lax,
  }) {
    final cookie = Cookie(name, value)
      ..expires = expires
      ..maxAge = maxAge
      ..domain = domain
      ..path = path ?? '/'
      ..secure = secure
      ..httpOnly = httpOnly;

    if (sameSite != null) {
      cookie.sameSite = sameSite;
    }

    _replaceCookie(cookie);
  }

  /// Removes a cookie by setting an expired value for the provided name.
  void clearCookie(String name, {String? path, String? domain}) {
    final cookie = Cookie(name, '')
      ..maxAge = 0
      ..expires = DateTime.utc(1970)
      ..path = path
      ..domain = domain;
    _replaceCookie(cookie);
  }

  /// Returns `true` when a cookie with the given [name] (and optional [path])
  /// is queued for the response.
  bool hasCookie(String name, {String? path}) {
    return _cookies.any((cookie) {
      if (cookie.name != name) return false;
      if (path == null) return true;
      return (cookie.path ?? '/') == path;
    });
  }

  /// Serialises a JSON payload and updates the response metadata accordingly.
  void json(Map<String, dynamic> data, {int? statusCode}) {
    body = jsonEncode(data);
    headers['Content-Type'] = ContentType.json.mimeType;
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Writes a plain text payload to the response.
  void text(String data, {int? statusCode}) {
    body = data;
    headers['Content-Type'] = ContentType.text.mimeType;
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Writes an HTML payload to the response.
  void html(String html, {int? statusCode}) {
    body = html;
    headers['Content-Type'] = ContentType.html.mimeType;
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Writes an XML payload to the response.
  void xml(String xml, {int? statusCode}) {
    body = xml;
    headers['Content-Type'] = 'application/xml';
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Streams raw bytes to the client using the supplied content-type.
  void bytes(Uint8List bytes,
      {String contentType = 'application/octet-stream', int? statusCode}) {
    body = bytes;
    isBinary = true;
    headers['Content-Type'] = contentType;
    headers['Content-Length'] = bytes.length.toString();
    if (statusCode != null) {
      setStatus(statusCode);
    }
  }

  /// Reads a file from disk and emits it as the response body. Responds with
  /// a 404 when the file does not exist.
  Future<void> file(
    File file,
  ) async {
    if (await file.exists()) {
      final bytes = await file.readAsBytes();
      this.bytes(bytes, contentType: _getContentType(file.path));
    } else {
      statusCode = HttpStatus.notFound;
      text('File not found');
    }
  }

  /// Issues an HTTP redirect by setting the appropriate status code and
  /// `Location` header.
  void redirect(String url, {int status = HttpStatus.movedPermanently}) {
    statusCode = status;
    headers['Location'] = url;
  }

  static String _getContentType(String filePath) {
    return lookupMimeType(filePath) ?? 'application/octet-stream';
  }

  /// Flushes the accumulated headers/cookies into the provided [HttpResponse]
  /// and closes the sink. Subsequent invocations are ignored.
  void send(HttpResponse httpResponse) {
    if (isSent) return;
    _writeCookies(httpResponse);
    _isSent = true;

    httpResponse.statusCode = statusCode;

    headers.forEach((name, value) {
      httpResponse.headers.set(name, value);
    });

    if (isBinary) {
      httpResponse.add(body as Uint8List);
    } else if (body != null) {
      httpResponse.write(body);
    }

    httpResponse.close();
  }

  void setHeader(String name, String value) {
    headers[name] = value;
  }

  void setStatus(int code) {
    statusCode = code;
  }

  void _writeCookies(HttpResponse httpResponse) {
    if (_cookies.isEmpty) {
      return;
    }

    for (final cookie in _cookies) {
      httpResponse.cookies.add(cookie);
    }
  }

  void _replaceCookie(Cookie cookie) {
    _cookies.removeWhere((existing) {
      final sameName = existing.name == cookie.name;
      final existingPath = existing.path ?? '/';
      final newPath = cookie.path ?? '/';
      return sameName && existingPath == newPath;
    });
    _cookies.add(cookie);
  }
}

-------- [ Separator ] ------

File Name: lib/src/models/session_signer.dart
Size: 2.05 KB
Code:
import 'dart:convert';
import 'package:crypto/crypto.dart';

/// Provides session cookie signing and verification using HMAC-SHA256.
///
/// Session cookies are signed to prevent tampering. The signature is appended
/// to the session ID using the format: `sessionId.signature`.
class SessionSigner {
  final String secret;
  final String _separator = '.';

  SessionSigner(this.secret) {
    if (secret.isEmpty) {
      throw ArgumentError('Session secret cannot be empty');
    }
    if (secret.length < 32) {
      throw ArgumentError(
          'Session secret must be at least 32 characters for security');
    }
  }

  /// Signs a session ID and returns the signed value.
  ///
  /// Format: `sessionId.signature`
  String sign(String sessionId) {
    final signature = _generateSignature(sessionId);
    return '$sessionId$_separator$signature';
  }

  /// Verifies and extracts the session ID from a signed value.
  ///
  /// Returns the original session ID if the signature is valid, or null if
  /// the signature is invalid or the format is incorrect.
  String? verify(String signedValue) {
    final parts = signedValue.split(_separator);
    if (parts.length != 2) {
      return null; // Invalid format
    }

    final sessionId = parts[0];
    final providedSignature = parts[1];
    final expectedSignature = _generateSignature(sessionId);

    // Use constant-time comparison to prevent timing attacks
    if (_secureCompare(providedSignature, expectedSignature)) {
      return sessionId;
    }

    return null; // Invalid signature
  }

  String _generateSignature(String value) {
    final key = utf8.encode(secret);
    final bytes = utf8.encode(value);
    final hmac = Hmac(sha256, key);
    final digest = hmac.convert(bytes);
    return digest.toString();
  }

  /// Constant-time string comparison to prevent timing attacks
  bool _secureCompare(String a, String b) {
    if (a.length != b.length) {
      return false;
    }

    var result = 0;
    for (var i = 0; i < a.length; i++) {
      result |= a.codeUnitAt(i) ^ b.codeUnitAt(i);
    }

    return result == 0;
  }
}

-------- [ Separator ] ------

File Name: lib/src/models/session_store.dart
Size: 3.92 KB
Code:
import 'dart:async';

/// Abstract interface for session persistence backends.
///
/// Implement this interface to create custom session stores using
/// Redis, PostgreSQL, MongoDB, or any other persistence layer.
///
/// ## Built-in Implementations
/// - [MemorySessionStore]: In-memory storage (default, not for production multi-instance)
///
/// ## Example: Redis Implementation
/// ```dart
/// class RedisSessionStore implements SessionStore {
///   final RedisConnection redis;
///
///   RedisSessionStore(this.redis);
///
///   @override
///   Future<Map<String, dynamic>?> load(String sessionId) async {
///     final data = await redis.get('session:$sessionId');
///     return data != null ? jsonDecode(data) : null;
///   }
///
///   @override
///   Future<void> save(String sessionId, Map<String, dynamic> data, {Duration? ttl}) async {
///     final value = jsonEncode(data);
///     if (ttl != null) {
///       await redis.setex('session:$sessionId', ttl.inSeconds, value);
///     } else {
///       await redis.set('session:$sessionId', value);
///     }
///   }
///
///   @override
///   Future<void> destroy(String sessionId) async {
///     await redis.del('session:$sessionId');
///   }
/// }
/// ```
abstract class SessionStore {
  /// Loads session data for the given [sessionId].
  ///
  /// Returns a map of session data, or `null` if the session doesn't exist
  /// or has expired.
  ///
  /// **Implementation Notes**:
  /// - Return a new map instance (don't return internal references)
  /// - Handle expired sessions by returning null
  /// - Should be idempotent (calling multiple times returns same data)
  Future<Map<String, dynamic>?> load(String sessionId);

  /// Saves session data for the given [sessionId].
  ///
  /// Parameters:
  /// - [sessionId]: Unique session identifier
  /// - [data]: Session data to persist
  /// - [ttl]: Time-to-live for the session (optional)
  ///
  /// **Implementation Notes**:
  /// - Store a copy of data (don't store references)
  /// - If [ttl] is provided, session should expire after that duration
  /// - Should handle concurrent writes safely
  /// - Should be atomic (all-or-nothing)
  Future<void> save(
    String sessionId,
    Map<String, dynamic> data, {
    Duration? ttl,
  });

  /// Destroys the session with the given [sessionId].
  ///
  /// After calling this, [load] should return `null` for this session.
  ///
  /// **Implementation Notes**:
  /// - Should be idempotent (destroying non-existent session is OK)
  /// - Should clean up all related data
  Future<void> destroy(String sessionId);

  /// Extends the lifetime of the session without modifying data.
  ///
  /// Useful for implementing sliding session expiration where sessions
  /// automatically extend when users are active.
  ///
  /// Parameters:
  /// - [sessionId]: Session to touch
  /// - [ttl]: New time-to-live duration
  ///
  /// **Implementation Notes**:
  /// - If session doesn't exist, this is a no-op
  /// - Only updates expiration timestamp, not data
  /// - Optional to implement (can be no-op if store auto-expires)
  Future<void> touch(String sessionId, {Duration? ttl}) async {
    // Default implementation: no-op
    // Override if your store supports TTL extension
  }

  /// Cleans up expired sessions.
  ///
  /// Called periodically to remove stale sessions. Not needed for stores
  /// that automatically expire sessions (like Redis).
  ///
  /// **Implementation Notes**:
  /// - Can be a no-op if store handles expiration automatically
  /// - Should be safe to run concurrently
  /// - Should not block for long periods
  Future<void> cleanup() async {
    // Default implementation: no-op
    // Override if your store needs manual cleanup
  }

  /// Disposes resources held by this store.
  ///
  /// Called when the server shuts down. Use this to close database
  /// connections, cancel timers, etc.
  Future<void> dispose() async {
    // Default implementation: no-op
    // Override if your store needs cleanup
  }
}

-------- [ Separator ] ------

File Name: lib/src/router/listRouter/listRouter.dart
Size: 27 B
Code:
export 'list_router.dart';

-------- [ Separator ] ------

File Name: lib/src/router/listRouter/list_router.dart
Size: 1.40 KB
Code:
// list_router.dart
import 'package:dart_express/dart_express.dart';
import 'package:dart_express/src/router/router_interface.dart';

part 'route_entry.dart';

class ListRouter implements RouterInterface {
  final Map<String, _RouteEntry> _isolatedRoutes = {};
  final List<_RouteEntry> _routes = [];

  @override
  void addRoute(String method, String path, RequestHandler handler) {
    _routes.add(_RouteEntry.route(method, path, handler));
  }

  @override
  void addIsolatedRouter(String prefix, RouterInterface router) {
    if (_isolatedRoutes.containsKey(prefix)) {
      throw RouteConflictError(
          'Isolated router already exists at prefix: $prefix');
    }
    _isolatedRoutes[prefix] = _RouteEntry.isolated(prefix, router);
  }

  @override
  RouteMatch? findRoute(String method, String path) {
    // First check isolated routers
    for (final entry in _isolatedRoutes.values) {
      if (path.startsWith(entry.prefix!)) {
        final remainingPath = path.substring(entry.prefix!.length);
        final normalizedPath = remainingPath.isEmpty ? '' : remainingPath;
        return entry.isolatedRouter!.findRoute(method, normalizedPath);
      }
    }

    // Then check regular routes
    for (var route in _routes) {
      if (route.matches(method, path)) {
        return RouteMatch(
          route.handler,
          pathParams: route.extractParams(path),
        );
      }
    }
    return null;
  }
}

-------- [ Separator ] ------

File Name: lib/src/router/listRouter/route_entry.dart
Size: 1.86 KB
Code:
// route_entry.dart
part of 'list_router.dart';

class _RoutePattern {
  final RegExp regex;
  final List<String> paramNames;

  _RoutePattern(this.regex, this.paramNames);

  static _RoutePattern parse(String path) {
    final paramNames = <String>[];
    var pattern = path;

    pattern = pattern.replaceAllMapped(
        RegExp(r':([a-zA-Z][a-zA-Z0-9_]*)\(([^)]+)\)'), (match) {
      paramNames.add(match.group(1)!);
      return '(${match.group(2)})';
    });

    pattern =
        pattern.replaceAllMapped(RegExp(r':([a-zA-Z][a-zA-Z0-9_]*)'), (match) {
      paramNames.add(match.group(1)!);
      return '([^/]+)';
    });

    pattern = pattern.replaceAll('/', '\\/');
    final regex = RegExp('^$pattern/?\$');
    return _RoutePattern(regex, paramNames);
  }

  bool matches(String path) => regex.hasMatch(path);

  Map<String, String> extractParams(String path) {
    final match = regex.firstMatch(path);
    if (match == null) return {};
    final params = <String, String>{};
    for (var i = 0; i < paramNames.length; i++) {
      params[paramNames[i]] = match.group(i + 1)!;
    }
    return params;
  }
}

class _RouteEntry {
  final String method;
  final _RoutePattern pattern;
  final RequestHandler handler;
  final RouterInterface? isolatedRouter;
  final String? prefix;

  _RouteEntry.route(this.method, String path, this.handler)
      : pattern = _RoutePattern.parse(path),
        isolatedRouter = null,
        prefix = null;

  _RouteEntry.isolated(this.prefix, this.isolatedRouter)
      : method = '',
        pattern = _RoutePattern.parse(prefix!),
        handler = ((req, res) => Future.value());

  bool matches(String method, String path) {
    if (isolatedRouter != null) {
      return path.startsWith(prefix!);
    }
    return this.method == method && pattern.matches(path);
  }

  Map<String, String> extractParams(String path) => pattern.extractParams(path);
}

-------- [ Separator ] ------

File Name: lib/src/router/radixRouter/radixRouter.dart
Size: 28 B
Code:
export 'radix_router.dart';

-------- [ Separator ] ------

File Name: lib/src/router/radixRouter/radix_node.dart
Size: 1.47 KB
Code:
// radix_node.dart
part of 'radix_router.dart';

/// Represents a node in the radix tree routing structure
class RadixNode {
  /// The path segment this node represents
  final String segment;

  /// Child nodes keyed by their segment
  final Map<String, RadixNode> children = {};

  /// Named parameter for dynamic segments (null for static nodes)
  final String? paramName;

  /// Regex constraint for parameter validation (null for wildcards/static)
  final RegExp? regex;

  /// Registered handlers for different HTTP methods
  final Map<String, RequestHandler> handlers = {};
  RouterInterface? isolatedRouter;
  RadixNode._({
    required this.segment,
    this.paramName,
    this.regex,
  });

  /// Create root node
  factory RadixNode.root() => RadixNode._(segment: '');

  /// Create static route node
  factory RadixNode.static(String segment) => RadixNode._(segment: segment);

  /// Create dynamic route node
  factory RadixNode.dynamic(String segment, String paramName, RegExp? regex) =>
      RadixNode._(segment: segment, paramName: paramName, regex: regex);

  /// Whether this node represents a static path segment
  bool get isStatic => paramName == null;

  /// Whether this node represents a regex-constrained parameter
  bool get isRegex => isDynamic && regex != null;

  /// Whether this node represents a wildcard parameter
  bool get isWildcard => isDynamic && regex == null;

  /// Whether this node represents a dynamic parameter
  bool get isDynamic => paramName != null;
}

-------- [ Separator ] ------

File Name: lib/src/router/radixRouter/radix_router.dart
Size: 5.26 KB
Code:
// radix_router.dart
import 'package:dart_express/dart_express.dart';
import 'package:dart_express/src/router/router_interface.dart';

part 'radix_node.dart';

/// A high-performance router using a radix tree structure for efficient route matching.
/// Supports:
/// - Static routes (/users/profile)
/// - Parameter routes with regex constraints (/users/:id(\d+))
/// - Wildcard parameters (/users/:username)
///
/// Route matching priority:
/// 1. Static routes
/// 2. Regex-constrained parameters
/// 3. Wildcard parameters
class RadixRouter implements RouterInterface {
  final RadixNode _root = RadixNode.root();

  @override
  void addRoute(String method, String path, RequestHandler handler) {
    final normalizedPath = _normalizePath(path);

    final segments = _splitPath(normalizedPath);
    var currentNode = _root;

    for (final segment in segments) {
      currentNode = _getOrCreateNode(currentNode, segment);
    }

    if (currentNode.handlers.containsKey(method)) {
      throw RouteConflictError('Handler already exists for $method $path');
    }
    currentNode.handlers[method] = handler;
  }

  @override
  void addIsolatedRouter(String prefix, RouterInterface router) {
    final normalizedPrefix = _normalizePath(prefix);
    final segments = _splitPath(normalizedPrefix);

    var currentNode = _root;
    for (final segment in segments) {
      currentNode = _getOrCreateNode(currentNode, segment);
    }

    if (currentNode.isolatedRouter != null) {
      throw RouteConflictError(
          'Isolated router already exists at prefix: $prefix');
    }
    currentNode.isolatedRouter = router;
  }

  @override
  RouteMatch? findRoute(String method, String path) {
    final normalizedPath = _normalizePath(path);
    final segments = _splitPath(normalizedPath);
    final params = <String, String>{};

    return _findRouteMatch(_root, segments, 0, method, params);
  }

  RouteMatch? _findRouteMatch(
    RadixNode node,
    List<String> segments,
    int depth,
    String method,
    Map<String, String> params,
  ) {
    // Check if current node has an isolated router
    if (node.isolatedRouter != null && depth <= segments.length) {
      final remainingSegments = segments.skip(depth);
      final remainingPath =
          remainingSegments.isEmpty ? '' : remainingSegments.join('/');
      return node.isolatedRouter!.findRoute(method, remainingPath);
    }

    // End of path - check for handler
    if (depth == segments.length) {
      final handler = node.handlers[method];
      return handler != null ? RouteMatch(handler, pathParams: params) : null;
    }

    final segment = segments[depth];
    final processed = <RadixNode>[];

    // Static routes first
    for (final child in node.children.values) {
      if (child.isStatic && child.segment == segment) {
        final match =
            _findRouteMatch(child, segments, depth + 1, method, params);
        if (match != null) return match;
        processed.add(child);
      }
    }

    // Then regex routes
    for (final child in node.children.values
        .where((c) => c.isRegex && !processed.contains(c))) {
      if (child.regex!.hasMatch(segment)) {
        final paramBackup = _handleParam(child, params, segment);
        final match =
            _findRouteMatch(child, segments, depth + 1, method, params);
        if (match != null) return match;
        _restoreParam(child, params, paramBackup);
        processed.add(child);
      }
    }

    // Finally wildcard routes
    for (final child in node.children.values
        .where((c) => c.isWildcard && !processed.contains(c))) {
      final paramBackup = _handleParam(child, params, segment);
      final match = _findRouteMatch(child, segments, depth + 1, method, params);
      if (match != null) return match;
      _restoreParam(child, params, paramBackup);
    }

    return null;
  }

  RadixNode _getOrCreateNode(RadixNode parent, String segment) {
    if (parent.children.containsKey(segment)) {
      return parent.children[segment]!;
    }

    final newNode = _createNode(segment);
    parent.children[segment] = newNode;
    return newNode;
  }

  RadixNode _createNode(String segment) {
    if (segment.startsWith(':')) {
      final match =
          RegExp(r':([a-zA-Z_]\w*)(?:\(([^)]+)\))?').firstMatch(segment);
      if (match == null) {
        throw FormatException('Invalid path segment: $segment');
      }

      final paramName = match.group(1)!;
      final regex =
          match.group(2) != null ? RegExp('^${match.group(2)}\$') : null;

      return RadixNode.dynamic(segment, paramName, regex);
    }
    return RadixNode.static(segment);
  }

  String _normalizePath(String path) => path
      .replaceAll(RegExp(r'/+'), '/') // Collapse multiple slashes
      .replaceAll(RegExp(r'^/|/$'), ''); // Trim leading/trailing slashes

  List<String> _splitPath(String path) => path.split('/');

  String? _handleParam(
      RadixNode node, Map<String, String> params, String value) {
    if (!node.isDynamic) return null;
    final backup = params[node.paramName!];
    params[node.paramName!] = value;
    return backup;
  }

  void _restoreParam(
      RadixNode node, Map<String, String> params, String? backup) {
    if (!node.isDynamic) return;
    if (backup != null) {
      params[node.paramName!] = backup;
    } else {
      params.remove(node.paramName!);
    }
  }
}

-------- [ Separator ] ------

File Name: lib/src/router/router.dart
Size: 76 B
Code:
export 'listRouter/listRouter.dart';
export 'radixRouter/radixRouter.dart';

-------- [ Separator ] ------

File Name: lib/src/router/router_interface.dart
Size: 949 B
Code:
import 'package:dart_express/dart_express.dart';

/// Defines the common interface for all router implementations
abstract class RouterInterface {
  /// Add a route to the router
  /// [method] - HTTP method (GET, POST, etc.)
  /// [path] - URL path pattern with optional parameters
  /// [handler] - Request handler function
  void addRoute(String method, String path, RequestHandler handler);

  /// Find a matching route for incoming request
  /// Returns [RouteMatch] with handler and parameters if found
  RouteMatch? findRoute(String method, String path);

  void addIsolatedRouter(String prefix, RouterInterface router);
}

/// Container for matched route results
class RouteMatch {
  /// The request handler to execute
  final RequestHandler handler;

  /// Path parameters extracted from the URL
  final Map<String, String> pathParams;

  RouteMatch(this.handler, {Map<String, String>? pathParams})
      : pathParams = pathParams ?? {};
}

-------- [ Separator ] ------

File Name: lib/src/services/base_container.dart
Size: 8.31 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:get_it/get_it.dart';
import 'package:meta/meta.dart';
import 'package:logger/logger.dart';

import '../router/router_interface.dart';

/// Core runtime wiring shared by [DartExpress] and other container variants.
/// Provides middleware composition, dependency registration helpers, and
/// request lifecycle utilities.
abstract class BaseContainer {
  final RouterInterface router;
  final List<MiddlewareHandler> _middleware = [];
  final GetIt container;
  final bool secureCookies;
  ErrorHandler? _errorHandler;
  late final Logger logger;

  /// Creates a container with optional overrides for router and dependency
  /// scope.
  BaseContainer({
    RouterInterface? router,
    GetIt? container,
    Logger? logger,
    this.secureCookies = true,
  })  : router = router ?? RadixRouter(),
        container = container ?? GetIt.instance {
    this.logger = logger ?? _defaultLogger();
  }

  /// Adds a global [middleware] to the container.
  void use(MiddlewareHandler middleware) {
    _middleware.add(middleware);
  }

  /// Registers a pre-built [instance] that will be served for type [T].
  void inject<T extends Object>(T instance) {
    container.registerSingleton<T>(instance);
  }

  /// Registers an eagerly created singleton for [T].
  void registerSingleton<T extends Object>(T instance) {
    container.registerSingleton<T>(instance);
  }

  /// Registers a factory invoked on each access to [T].
  void registerFactory<T extends Object>(T Function() factoryFunc) {
    container.registerFactory<T>(factoryFunc);
  }

  /// Registers a lazily created singleton for [T].
  void registerLazySingleton<T extends Object>(T Function() factoryFunc) {
    container.registerLazySingleton<T>(factoryFunc);
  }

  /// Registers an asynchronously produced singleton.
  void registerSingletonAsync<T extends Object>(
      Future<T> Function() asyncFactoryFunc) {
    container.registerSingletonAsync<T>(asyncFactoryFunc);
  }

  /// Registers an asynchronously produced factory provider.
  void registerFactoryAsync<T extends Object>(
      Future<T> Function() asyncFactoryFunc) {
    container.registerFactoryAsync<T>(asyncFactoryFunc);
  }

  /// Registers an asynchronously produced lazy singleton.
  void registerLazySingletonAsync<T extends Object>(
      Future<T> Function() asyncFactoryFunc) {
    container.registerLazySingletonAsync<T>(asyncFactoryFunc);
  }

  /// Checks whether [T] is already registered.
  bool isRegistered<T extends Object>({Object? instance}) {
    return container.isRegistered<T>(instance: instance);
  }

  /// Unregisters the existing binding for [T].
  void unregister<T extends Object>() {
    container.unregister<T>();
  }

  /// Installs a global error handler.
  void setErrorHandler(ErrorHandler handler) {
    _errorHandler = handler;
  }

  @protected
  RequestHandler wrapWithMiddleware(
      RequestHandler handler, List<MiddlewareHandler> routeMiddleware) {
    return (Request request, Response response) async {
      int globalIndex = 0;
      int routeIndex = 0;

      Future<void> runNextMiddleware() async {
        if (globalIndex < _middleware.length) {
          await _middleware[globalIndex++](
              request, response, runNextMiddleware);
        } else if (routeIndex < routeMiddleware.length) {
          await routeMiddleware[routeIndex++](
              request, response, runNextMiddleware);
        } else {
          await handler(request, response);
        }
      }

      await runNextMiddleware();
    };
  }

  @protected
  void addRoute(String method, String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final wrappedHandler = wrapWithMiddleware(handler, middleware ?? []);
    router.addRoute(method, path, wrappedHandler);
  }

  /// Orchestrates the full request lifecycle: building framework abstractions,
  /// resolving routes, executing middleware/handlers and finally flushing the
  /// response (including error handling and session propagation).
  @protected
  Future<void> handleRequest(HttpRequest httpRequest) async {
    final request = Request.from(httpRequest, container: container);
    final response = Response();
    await processRequest(request, response);
  }

  /// Executes middleware + handler pipeline for a prepared [request] and
  /// [response]. If a route does not complete the response, it is sent here.
  @protected
  Future<void> processRequest(Request request, Response response) async {
    // Load session data from store (with error handling)
    try {
      await request.session.load();
    } catch (e, stack) {
      logger.e('Failed to load session', error: e, stackTrace: stack);
      // Continue with empty session rather than crashing request
    }

    // Set up session cookie for new sessions
    if (request.isNewSession &&
        !response.hasCookie(Request.sessionCookieName)) {
      // Determine session cookie value (signed or plain)
      String cookieValue = request.session.id;
      if (request.sessionSigner != null) {
        cookieValue = request.sessionSigner!.sign(request.session.id);
      }

      // Set session cookie with configured security settings
      response.cookie(
        Request.sessionCookieName,
        cookieValue,
        secure: secureCookies,
        httpOnly: true,
        sameSite: SameSite.lax,
      );
    }

    // Attach request correlation id to response for tracing
    response.setHeader('X-Request-Id', request.requestId);

    try {
      final resolvedPath = resolveRoutePath(request);
      final routeMatch = router.findRoute(request.method, resolvedPath);
      request.params = routeMatch?.pathParams ?? {};
      if (routeMatch != null) {
        await routeMatch.handler(request, response);
      } else {
        throw NotFoundError('Route not found: $resolvedPath');
      }
    } catch (error, stackTrace) {
      await handleError(error, request, response, stackTrace);
    }

    // Save session data to store if modified (with error handling)
    try {
      await request.session.save();
    } catch (e, stack) {
      logger.e('Failed to save session', error: e, stackTrace: stack);
      // Log error but don't fail the request
    }

    if (!response.isSent) {
      response.send(request.httpRequest.response);
    }
  }

  /// Resolves the path used for route lookup. Subclasses can override to provide
  /// custom behaviour (e.g., stripping a mount prefix).
  @protected
  String resolveRoutePath(Request request) => request.uri.path;

  /// Default error handling entry point. Subclasses may override to plug in
  /// different behaviour.
  @protected
  Future<void> handleError(dynamic error, Request request, Response response,
      StackTrace stackTrace) async {
    if (_errorHandler != null) {
      try {
        await _errorHandler!(error, request, response);
        // Ensure error handler actually sent a response
        if (!response.isSent) {
          logger.w(
              'Error handler did not send response, using fallback for ${request.method} ${request.uri.path}');
          _sendDefaultError(error, response, stackTrace);
        }
      } catch (e, st) {
        logger.e(
            'Error in error handler for ${request.method} ${request.uri.path}',
            error: e,
            stackTrace: st);
        // Fall through to default error handling
        if (!response.isSent) {
          _sendDefaultError(error, response, stackTrace);
        }
      }
    } else {
      _sendDefaultError(error, response, stackTrace);
    }
  }

  void _sendDefaultError(
      dynamic error, Response response, StackTrace stackTrace) {
    if (response.isSent) return;

    logger.e('Unhandled error', error: error, stackTrace: stackTrace);
    if (error is HttpError) {
      response.setStatus(error.statusCode);
      response.json({'error': error.message, 'data': error.data});
    } else {
      response.setStatus(HttpStatus.internalServerError);
      response.json(
          {'error': 'Internal Server Error', 'message': error.toString()});
    }
  }

  /// Disposes the dependency container and any subclass resources.
  Future<void> onDispose() async {
    container.reset();
  }

  static Logger _defaultLogger() {
    return Logger(
      printer: PrettyPrinter(
        methodCount: 0,
        errorMethodCount: 5,
        lineLength: 120,
        printEmojis: false,
        dateTimeFormat: DateTimeFormat.none,
      ),
    );
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/controller.dart
Size: 2.32 KB
Code:
import 'package:meta/meta.dart';

import '../models/middleware.dart';
import 'dart_express.dart';

/// Helper passed to controllers so they can register routes relative to their
/// configured prefix without duplicating boilerplate.
class ControllerOptions {
  late final DartExpress _app;
  late final String _prefix;
  ControllerOptions(this._app, this._prefix);
  /// Registers a `GET` handler relative to the controller prefix.
  void get(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.get(fullPath, handler, middleware: middleware);
  }

  /// Registers a `POST` handler relative to the controller prefix.
  void post(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.post(fullPath, handler, middleware: middleware);
  }

  /// Registers a `PUT` handler relative to the controller prefix.
  void put(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.put(fullPath, handler, middleware: middleware);
  }

  /// Registers a `PATCH` handler relative to the controller prefix.
  void patch(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.patch(fullPath, handler, middleware: middleware);
  }

  /// Registers a `DELETE` handler relative to the controller prefix.
  void delete(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    final fullPath = _joinPaths(path);
    _app.delete(fullPath, handler, middleware: middleware);
  }

  String _joinPaths(String path) {
    if (_prefix.isEmpty) return path;
    if (path.startsWith('/')) path = path.substring(1);
    return '${_prefix.endsWith('/') ? _prefix : '$_prefix/'}$path';
  }
}

/// Base class for feature modules that register routes using
/// [ControllerOptions]. Override [registerRoutes] to declare handlers.
abstract class Controller {
  late final ControllerOptions _options;
  @mustCallSuper
  void initialize(DartExpress app, {required String prefix}) {
    _options = ControllerOptions(app, prefix);
    registerRoutes(_options);
  }

  /// Subclasses implement this to register routes.
  void registerRoutes(ControllerOptions options);
}

-------- [ Separator ] ------

File Name: lib/src/services/dart_express.dart
Size: 14.41 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:dart_express/src/middleware/cookies_parser.dart';
import 'package:get_it/get_it.dart';
import 'package:logger/logger.dart';
import '../router/router_interface.dart';

/// Common HTTP method constants used across the framework.
class RequestTypes {
  static const String GET = 'GET';
  static const String POST = 'POST';
  static const String PUT = 'PUT';
  static const String PATCH = 'PATCH';
  static const String DELETE = 'DELETE';
  static const String OPTIONS = 'OPTIONS';

  static const List<String> allTypes = [GET, POST, PUT, PATCH, DELETE, OPTIONS];
}

/// DartExpress is a lightweight web framework for Dart, inspired by Express.js.
/// Provides routing helpers, middleware registration and server lifecycle
/// management around a standard [HttpServer].
class DartExpress extends BaseContainer {
  final int maxBodySize;
  final int maxFileSize;
  final Duration requestTimeout;
  final Duration shutdownTimeout;
  final String? sessionSecret;
  final SessionStore? sessionStore;
  final SessionSigner? _sessionSigner;
  int _activeRequests = 0;
  bool _isShuttingDown = false;
  final DateTime _startTime = DateTime.now();

  DartExpress({
    bool useCookieParser = true,
    this.maxBodySize = 10 * 1024 * 1024, // 10MB
    this.maxFileSize = 100 * 1024 * 1024, // 100MB
    this.requestTimeout = const Duration(seconds: 30),
    this.shutdownTimeout = const Duration(seconds: 30),
    this.sessionSecret,
    this.sessionStore,
    bool secureCookies = true,
    Logger? logger,
    RouterInterface? router,
    GetIt? container,
  })  : _sessionSigner =
            sessionSecret != null ? SessionSigner(sessionSecret) : null,
        super(
          container: container,
          router: router,
          logger: logger,
          secureCookies: secureCookies,
        ) {
    _validateConfig();
    if (useCookieParser) {
      use(CookieParser.middleware());
    }
  }

  /// Mounts a controller under the provided [prefix]. Routes registered inside
  /// the controller will automatically inherit the prefix.
  void useController(String prefix, Controller controller) {
    controller.initialize(this, prefix: prefix);
  }

  /// Registers a `GET` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void get(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.GET, path, handler, middleware: middleware);
  }

  /// Registers a `POST` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void post(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.POST, path, handler, middleware: middleware);
  }

  /// Registers a `PUT` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void put(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PUT, path, handler, middleware: middleware);
  }

  /// Registers a `PATCH` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void patch(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PATCH, path, handler, middleware: middleware);
  }

  /// Registers a `DELETE` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void delete(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.DELETE, path, handler, middleware: middleware);
  }

  /// Registers an `OPTIONS` handler at [path]. Optional [middleware] run after
  /// global middleware but before the handler executes.
  void options(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.OPTIONS, path, handler, middleware: middleware);
  }

  final Map<HttpServer, Future<void>> _serverLifecycles = {};

  @override
  Future<void> handleRequest(HttpRequest httpRequest) async {
    final request = Request.from(
      httpRequest,
      container: container,
      maxBodySize: maxBodySize,
      maxFileSize: maxFileSize,
      sessionSigner: _sessionSigner,
      sessionStore: sessionStore,
    );
    final response = Response();
    await processRequest(request, response);
  }

  /// Binds an [HttpServer] on the provided [port] (and optional [address]) and
  /// starts processing incoming requests in the background. The returned server
  /// can be closed by the caller when shutdown is required or during tests.
  Future<HttpServer> listen(
    int port, {
    InternetAddress? address,
    bool shared = false,
  }) async {
    address ??= InternetAddress.anyIPv4;
    final server = await HttpServer.bind(address, port, shared: shared);
    logger.i('Server listening on port ${server.port}');

    final lifecycle = _serve(server);
    _serverLifecycles[server] = lifecycle;
    lifecycle.whenComplete(() => _serverLifecycles.remove(server));

    return server;
  }

  /// Awaits the internal request-processing loop for [server], ensuring any
  /// teardown logic has completed once the server has been closed. Useful for
  /// integration tests where the server is created and disposed per test case.
  Future<void> waitUntilClosed(HttpServer server) async {
    final lifecycle = _serverLifecycles[server];
    if (lifecycle != null) {
      await lifecycle;
    }
  }

  /// Generates a CORS middleware using the provided allow lists. Handles
  /// pre-flight requests and applies common security headers.
  MiddlewareHandler cors({
    List<String> allowedOrigins = const ['*'],
    List<String> allowedMethods = RequestTypes.allTypes,
    List<String> allowedHeaders = const ['Content-Type', 'Authorization'],
    bool allowCredentials = false,
    int maxAge = 86400,
  }) {
    if (allowCredentials && allowedOrigins.contains('*')) {
      throw ArgumentError(
          'allowCredentials cannot be used with wildcard origins (*)');
    }

    return (request, response, next) async {
      final origin = request.headers.value('Origin');
      final method = request.method;

      // Check if the origin is allowed
      bool isAllowedOrigin(String? origin) {
        return origin != null &&
            (allowedOrigins.contains('*') || allowedOrigins.contains(origin));
      }

      final shouldEchoOrigin =
          allowedOrigins.isNotEmpty && !allowedOrigins.contains('*');

      if (shouldEchoOrigin && origin != null) {
        response.setHeader('Vary', 'Origin');
      }

      if (isAllowedOrigin(origin)) {
        // Set CORS headers
        final allowOriginHeader =
            allowedOrigins.contains('*') && !allowCredentials ? '*' : origin!;
        response.setHeader('Access-Control-Allow-Origin', allowOriginHeader);
        response.setHeader(
            'Access-Control-Allow-Methods', allowedMethods.join(', '));
        response.setHeader(
            'Access-Control-Allow-Headers', allowedHeaders.join(', '));
        response.setHeader('Access-Control-Max-Age', maxAge.toString());

        if (allowCredentials) {
          response.setHeader('Access-Control-Allow-Credentials', 'true');
        }

        // Handle preflight OPTIONS request
        if (method == 'OPTIONS') {
          response.setHeader(
              'Vary',
              response.headers['Vary'] == null
                  ? 'Origin'
                  : response.headers['Vary']!);
          response.setHeader(
              'Access-Control-Allow-Headers',
              request.headers.value('access-control-request-headers') ??
                  allowedHeaders.join(', '));
          response.setStatus(HttpStatus.noContent); // 204 No Content
          response.send(request.httpRequest.response);
          return;
        }
      } else if (origin != null && !isAllowedOrigin(origin)) {
        // If origin is not allowed, log and respond with 403 Forbidden
        logger.w('CORS denied - origin not allowed: $origin');
        response.setStatus(HttpStatus.forbidden);
        response.text('CORS policy does not allow this origin.');
        response.send(request.httpRequest.response);
        return;
      } else if (!allowedMethods.contains(method)) {
        // If method is not allowed, respond with 405 Method Not Allowed
        logger.w('CORS denied - method not allowed: $method');
        response.setStatus(HttpStatus.methodNotAllowed);
        response.text('Method not allowed.');
        response.send(request.httpRequest.response);
        return;
      }

      // Set additional security headers
      response.setHeader(
          'Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
      response.setHeader('X-Content-Type-Options', 'nosniff');
      response.setHeader('X-Frame-Options', 'DENY');

      await next();
    };
  }

  /// Builds a rate limiter middleware backed by [store] (or an in-memory
  /// default). Requests exceeding [maxRequests] within [window] receive a 429
  /// response. Customize [keyGenerator] to throttle by user/token/etc.
  MiddlewareHandler rateLimiter({
    int maxRequests = 100,
    Duration window = const Duration(minutes: 1),
    String Function(Request request)? keyGenerator,
    RateLimitStore? store,
  }) {
    final effectiveStore = store ?? MemoryRateLimitStore();
    return (request, response, next) async {
      final key = keyGenerator != null
          ? keyGenerator(request)
          : request.httpRequest.connectionInfo?.remoteAddress.address ??
              'unknown';

      final isAllowed =
          await effectiveStore.increment(key, maxRequests, window);

      if (!isAllowed) {
        response.setStatus(HttpStatus.tooManyRequests);
        response.text('Rate limit exceeded. Try again later.');
        return;
      }

      await next();
    };
  }

  /// Enable a simple health check endpoint at /health
  void enableHealthCheck() {
    get('/health', (req, res) {
      res.json({
        'status': 'ok',
        'uptime': DateTime.now().difference(_startTime).inSeconds,
        'activeRequests': _activeRequests,
      });
    });
  }

  /// Gracefully closes all servers, waiting for active requests to complete
  Future<void> close() async {
    _isShuttingDown = true;

    logger.i(
        'Graceful shutdown initiated. Waiting for $_activeRequests active requests...');

    final deadline = DateTime.now().add(shutdownTimeout);
    while (_activeRequests > 0 && DateTime.now().isBefore(deadline)) {
      await Future.delayed(const Duration(milliseconds: 100));
    }

    if (_activeRequests > 0) {
      logger.w(
          'Forcefully closing with $_activeRequests active requests still in-flight');
    } else {
      logger.i('All requests completed. Closing servers.');
    }

    // Allow a short grace window for late-arriving requests to receive 503s
    await Future.delayed(const Duration(milliseconds: 50));

    for (final server in _serverLifecycles.keys.toList()) {
      final lifecycle = _serverLifecycles[server];
      await server.close(force: _activeRequests > 0);
      if (lifecycle != null) {
        await lifecycle;
      }
    }

    _serverLifecycles.clear();
  }

  Future<void> _serve(HttpServer server) async {
    try {
      await for (final httpRequest in server) {
        // Fire and forget - no blocking, trust Dart's event loop
        unawaited(_handleRequestWithTimeout(httpRequest));
      }
    } finally {
      // Clean up session store resources
      if (sessionStore != null) {
        try {
          await sessionStore!.dispose();
        } catch (e, stack) {
          logger.e('Error disposing session store',
              error: e, stackTrace: stack);
        }
      }
      await onDispose();
    }
  }

  Future<void> _handleRequestWithTimeout(HttpRequest httpRequest) async {
    // Reject new requests during shutdown
    if (_isShuttingDown) {
      httpRequest.response
        ..statusCode = HttpStatus.serviceUnavailable
        ..headers.add('Connection', 'close')
        ..write('Server is shutting down')
        ..close();
      return;
    }

    _activeRequests++;

    try {
      await handleRequest(httpRequest).timeout(
        requestTimeout,
        onTimeout: () => throw HttpError(408, 'Request Timeout'),
      );
    } catch (error, stackTrace) {
      await _safelySendErrorResponse(httpRequest, error, stackTrace);
    } finally {
      _activeRequests--;
    }
  }

  Future<void> _safelySendErrorResponse(
    HttpRequest httpRequest,
    dynamic error,
    StackTrace stackTrace,
  ) async {
    logger.e(
        'Request error ${httpRequest.method} ${httpRequest.uri.path} '
        'reqId=${httpRequest.headers.value('x-request-id') ?? '-'}',
        error: error,
        stackTrace: stackTrace,
        time: DateTime.now());
    try {
      final statusCode = error is HttpError ? error.statusCode : 500;

      httpRequest.response
        ..statusCode = statusCode
        ..headers.contentType = ContentType.json
        ..write(jsonEncode({
          'error': error.toString(),
          'statusCode': statusCode,
        }));

      await httpRequest.response.close();
    } catch (_) {
      // If we can't send error response, just try to close
      try {
        await httpRequest.response.close();
      } catch (_) {
        // Nothing more we can do
      }
    }
  }

  void _validateConfig() {
    if (maxBodySize <= 0) {
      throw ArgumentError('maxBodySize must be positive');
    }
    if (maxFileSize <= 0) {
      throw ArgumentError('maxFileSize must be positive');
    }
    if (requestTimeout <= Duration.zero) {
      throw ArgumentError('requestTimeout must be positive');
    }
    if (shutdownTimeout <= Duration.zero) {
      throw ArgumentError('shutdownTimeout must be positive');
    }
    if (maxFileSize > maxBodySize) {
      logger.w(
          'maxFileSize ($maxFileSize) is greater than maxBodySize ($maxBodySize); large uploads may hit body limit first.');
    }
    if (secureCookies && sessionSecret == null) {
      logger.w(
          'secureCookies is enabled but no sessionSecret provided. Session cookies will not be signed. '
          'Set sessionSecret for production security.');
    }
    if (sessionStore == null) {
      logger.w('No session store provided. Using in-memory sessions. '
          'Sessions will be lost on restart and will NOT work with multiple instances. '
          'Set sessionStore to a persistent store (e.g., Redis) for production.');
    }
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/dependency_injection.dart
Size: 604 B
Code:
class DIContainer {
  final Map<Type, dynamic> _instances = {};
  final Map<Type, Function> _factories = {};

  void registerSingleton<T>(T instance) {
    _instances[T] = instance;
  }

  void registerFactory<T>(T Function() factory) {
    _factories[T] = factory;
  }

  T get<T>() {
    if (_instances.containsKey(T)) {
      return _instances[T] as T;
    }
    if (_factories.containsKey(T)) {
      final instance = _factories[T]!() as T;
      _instances[T] = instance; // Cache the instance
      return instance;
    }
    throw Exception('No instance or factory registered for type $T');
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/error_handler.dart
Size: 1018 B
Code:
import 'dart:async';
import 'dart:io';

import '../../dart_express.dart';

typedef ErrorHandler = FutureOr<void> Function(
    dynamic error, Request request, Response response);

class HttpError implements Exception {
  final int statusCode;
  final String message;
  final dynamic data;

  HttpError(this.statusCode, this.message, [this.data]);

  @override
  String toString() => 'HttpError: $statusCode - $message';
}

class ValidationError extends HttpError {
  ValidationError(String message, [dynamic data])
      : super(HttpStatus.badRequest, message, data);
}

class NotFoundError extends HttpError {
  NotFoundError(String message, [dynamic data])
      : super(HttpStatus.notFound, message, data);
}

class UnauthorizedError extends HttpError {
  UnauthorizedError(String message, [dynamic data])
      : super(HttpStatus.unauthorized, message, data);
}

class RouteConflictError extends HttpError {
  RouteConflictError(String message, [dynamic data])
      : super(HttpStatus.conflict, message, data);
}

-------- [ Separator ] ------

File Name: lib/src/services/isolated_container.dart
Size: 5.42 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:get_it/get_it.dart';

import '../router/router_interface.dart';

/// A container that can be mounted under a specific prefix with its own router,
/// middleware pipeline and dependency injection scope.
///
/// When mounted it reuses the parent [`Response`] instance so that cookies,
/// headers, and streaming behaviour are coordinated with the hosting
/// application while requests are rebuilt against the isolated dependency
/// scope.
class IsolatedContainer extends BaseContainer {
  IsolatedContainer({
    String prefix = '',
    super.router,
    GetIt? container,
  })  : prefix = _normalizePrefix(prefix),
        super(
          container: container ?? GetIt.asNewInstance(),
        );

  /// Public prefix exposed for introspection (always normalised to leading slash
  /// without trailing slash, except when empty).
  final String prefix;

  final Map<String, dynamic> cache = {};

  void get(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.GET, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void post(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.POST, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void put(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PUT, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void patch(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.PATCH, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void delete(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.DELETE, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  void options(String path, RequestHandler handler,
      {List<MiddlewareHandler>? middleware}) {
    addRoute(RequestTypes.OPTIONS, _normalizeLocalPath(path), handler,
        middleware: middleware);
  }

  /// Mounts this container into the provided [app], delegating only requests
  /// whose path matches the configured prefix via the parent router. This keeps
  /// path normalisation and parameter extraction consistent with the main
  /// routing strategy.
  void mount(DartExpress app) {
    final mountPrefix = prefix.isEmpty ? '/' : prefix;
    app.router.addIsolatedRouter(
      mountPrefix,
      _IsolatedRouterDelegate(this),
    );
  }

  /// Optional helper to run this container as a standalone service.
  Future<void> listen(int port, {InternetAddress? address}) async {
    address ??= InternetAddress.anyIPv4;
    final server = await HttpServer.bind(address, port);
    logger.i('Isolated container listening on port ${server.port}');
    await for (final httpRequest in server) {
      await handleRequest(httpRequest);
    }
  }

  @override
  String resolveRoutePath(Request request) {
    if (prefix.isEmpty) return request.uri.path;

    final path = request.uri.path;
    if (path == prefix || path == '$prefix/') {
      return '/';
    }

    final prefixedWithSlash = prefix.isEmpty ? '/' : '$prefix/';
    if (path.startsWith(prefixedWithSlash)) {
      final trimmed = path.substring(prefix.length);
      if (trimmed.isEmpty) return '/';
      return trimmed.startsWith('/') ? trimmed : '/$trimmed';
    }

    return request.uri.path;
  }

  @override
  Future<void> onDispose() {
    cache.clear();
    return super.onDispose();
  }

  /// Public hook to process a scoped request inside this container.
  Future<void> handleScoped(Request request, Response response) {
    return processRequest(request, response);
  }

  static String _normalizeLocalPath(String path) {
    if (path.isEmpty) return '/';
    return path.startsWith('/') ? path : '/$path';
  }

  static String _normalizePrefix(String prefix) {
    var value = prefix.trim();
    if (value.isEmpty || value == '/') {
      return '';
    }
    if (!value.startsWith('/')) {
      value = '/$value';
    }
    if (value.endsWith('/') && value.length > 1) {
      value = value.substring(0, value.length - 1);
    }
    return value;
  }
}

class _IsolatedRouterDelegate implements RouterInterface {
  _IsolatedRouterDelegate(this.container);

  final IsolatedContainer container;

  @override
  void addRoute(String method, String path, RequestHandler handler) {
    container.router.addRoute(method, path, handler);
  }

  @override
  void addIsolatedRouter(String prefix, RouterInterface router) {
    container.router.addIsolatedRouter(prefix, router);
  }

  @override
  RouteMatch? findRoute(String method, String path) {
    final delegateMatch = container.router.findRoute(method, path);
    if (delegateMatch == null) {
      return null;
    }

    return RouteMatch(
      (parentRequest, parentResponse) async {
        // Reuse parent session and store for isolated containers
        // This ensures session data is shared and persisted correctly
        final scopedRequest = Request(
          parentRequest.httpRequest,
          parentRequest.session, // Share session
          parentRequest.requestId,
          container.container,
          sessionSigner: parentRequest.sessionSigner,
        );

        await container.handleScoped(scopedRequest, parentResponse);
      },
      pathParams: delegateMatch.pathParams,
    );
  }
}

-------- [ Separator ] ------

File Name: lib/src/services/services.dart
Size: 248 B
Code:
export 'package:http/http.dart' show MultipartFile;

export './base_container.dart';
export './controller.dart';
export './dart_express.dart';
export './dependency_injection.dart';
export './error_handler.dart';
export './isolated_container.dart';

-------- [ Separator ] ------

File Name: melos_dart_express.iml
Size: 762 B
Code:
<?xml version="1.0" encoding="UTF-8"?>
<module type="WEB_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/test" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/.dart_tool" />
      <excludeFolder url="file://$MODULE_DIR$/.pub" />
      <excludeFolder url="file://$MODULE_DIR$/build" />
    </content>
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="Dart SDK" level="project" />
    <orderEntry type="library" name="Dart Packages" level="project" />
  </component>
</module>
-------- [ Separator ] ------

File Name: pubspec.yaml
Size: 447 B
Code:
name: dart_express
description: A starting point for Dart libraries or applications.
version: 1.0.0
# repository: https://github.com/my_org/my_repo

environment:
  sdk: ^3.6.0

# Add regular dependencies here.
dependencies:
  args: ^2.4.2
  async: ^2.11.0
  crypto: ^3.0.3
  get_it: ^8.0.3
  http: ^1.2.2
  logger: ^2.5.0
  meta: ^1.16.0
  mime: ^2.0.0
  uri: ^1.0.0
  uuid: ^4.5.1
  xml: ^6.5.0

dev_dependencies:
  lints: ^5.0.0
  test: ^1.24.0

-------- [ Separator ] ------

File Name: test/dart_express_test.dart
Size: 6.25 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

void main() {
  group('Application', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());

    tearDown(() async => harness.dispose());

    test('GET / returns 200 with correct body', () async {
      harness.app
          .get('/', (Request req, Response res) => res.text('Hello World!'));

      final response = await harness.get('/');

      expect(response.statusCode, 200);
      expect(response.body, 'Hello World!');
      expect(
          response.headers['set-cookie'], contains(Request.sessionCookieName));
    });

    test('POST / returns 201 with JSON response', () async {
      harness.app.post(
        '/',
        (Request req, Response res) =>
            res.json({'success': true}, statusCode: 201),
      );

      final response = await harness.post('/');

      expect(response.statusCode, 201);
      expect(response.headers['content-type'], 'application/json');
      expect(response.body, '{"success":true}');
    });

    test('Unknown route returns 404 with JSON payload', () async {
      final response = await harness.get('/not_found');

      expect(response.statusCode, 404);
      expect(response.headers['content-type'], 'application/json');
    });
    test('Reuses existing session cookie when provided', () async {
      final cookieHeader = '${Request.sessionCookieName}=existing-session';

      harness.app.get('/', (req, res) => res.text('OK'));

      final response = await harness.get(
        '/',
        headers: {HttpHeaders.cookieHeader: cookieHeader},
      );

      expect(response.statusCode, 200);
      // No duplicate cookie should be issued when already provided
      expect(response.headers['set-cookie'], isNull);
    });
  });

  group('Middleware', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Runs middleware in order', () async {
      final order = <int>[];

      harness.app.use((req, res, next) {
        order.add(1);
        return next();
      });

      harness.app.use((req, res, next) {
        order.add(2);
        return next();
      });

      harness.app.get('/middleware', (req, res) {
        order.add(3);
        res.text('OK');
      });

      final response = await harness.get('/middleware');

      expect(response.statusCode, 200);
      expect(order, [1, 2, 3]);
    });

    test('Middleware can modify response', () async {
      harness.app.use((req, res, next) {
        res.headers['X-Custom-Header'] = '123';
        return next();
      });

      harness.app.get('/header', (req, res) => res.text('OK'));

      final response = await harness.get('/header');

      expect(response.statusCode, 200);
      expect(response.headers['x-custom-header'], '123');
    });
  });

  group('Error Handling', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Unhandled error returns 500', () async {
      harness.app.get('/error', (req, res) => throw Exception('Test Error'));

      final response = await harness.get('/error');

      expect(response.statusCode, 500);
      expect(response.headers['content-type'], 'application/json');
    });
  });

  group('Route Parameters', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Parses route parameters', () async {
      harness.app.get('/users/:id', (req, res) {
        res.text('User ID: ${req.params['id']}');
      });

      final response = await harness.get('/users/123');

      expect(response.statusCode, 200);
      expect(response.body, 'User ID: 123');
    });
  });

  group('Isolated Container', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Routes and middleware execute in isolated scope', () async {
      final isolated = IsolatedContainer(prefix: '/island');
      isolated.use((req, res, next) {
        res.setHeader('X-Isolated', 'true');
        return next();
      });
      isolated.get('/', (req, res) => res.text('Isolated Root'));

      isolated.mount(harness.app);

      final response = await harness.get('/island');

      expect(response.statusCode, 200);
      expect(response.body, 'Isolated Root');
      expect(response.headers['x-isolated'], 'true');
    });

    test('Uses independent dependency injection scope', () async {
      final isolated = IsolatedContainer(prefix: '/island');

      harness.app.inject<Dependency>(Dependency('parent'));
      isolated.inject<Dependency>(Dependency('isolated'));

      isolated.get('/value', (req, res) {
        final dep = req.container.get<Dependency>();
        res.json({'value': dep.id});
      });

      isolated.mount(harness.app);

      final response = await harness.get('/island/value');

      expect(response.statusCode, 200);
      expect(response.body, '{"value":"isolated"}');

      final parentResponse = await harness.get('/missing');
      expect(parentResponse.statusCode, 404);
    });
  });
}

class TestServerHarness {
  final DartExpress app = DartExpress();
  HttpServer? _server;

  Future<http.Response> get(String path, {Map<String, String>? headers}) async {
    await _ensureServer();
    return http.get(_uri(path), headers: headers);
  }

  Future<http.Response> post(String path,
      {Object? body, Map<String, String>? headers}) async {
    await _ensureServer();
    return http.post(_uri(path), body: body, headers: headers);
  }

  Future<void> dispose() async {
    if (_server != null) {
      await _server!.close(force: true);
      await app.waitUntilClosed(_server!);
      _server = null;
    } else {
      await app.onDispose();
    }
  }

  Future<void> _ensureServer() async {
    if (_server != null) {
      return;
    }

    _server = await app.listen(0, address: InternetAddress.loopbackIPv4);
  }

  Uri _uri(String path) {
    final normalized = path.startsWith('/') ? path : '/$path';
    return Uri.parse('http://localhost:${_server!.port}$normalized');
  }
}

class Dependency {
  Dependency(this.id);
  final String id;
}

-------- [ Separator ] ------

File Name: test/helpers/test_server_harness.dart
Size: 3.06 KB
Code:
import 'dart:async';
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;

/// Lightweight harness that spins up a [DartExpress] instance on a random
/// ephemeral port and exposes helpers for common request patterns used in
/// tests.
class TestServerHarness {
  TestServerHarness({DartExpress? app, InternetAddress? address})
      : app = app ?? DartExpress(),
        address = address ?? InternetAddress.loopbackIPv4;

  final DartExpress app;
  final InternetAddress address;
  HttpServer? _server;
  int? _boundPort;

  int get port => _boundPort ?? _server?.port ?? 0;

  /// Starts the underlying [HttpServer] if not already running.
  Future<void> start() async {
    if (_server != null) return;
    _server = await app.listen(0, address: address);
    _boundPort = _server?.port;
  }

  /// Resolved absolute [Uri] for the given [path].
  Uri uri(String path) {
    final normalized = path.startsWith('/') ? path : '/$path';
    return Uri.parse('http://${address.address}:${port}$normalized');
  }

  Future<http.Response> get(String path,
      {Map<String, String>? headers}) async {
    await start();
    return http.get(uri(path), headers: headers);
  }

  Future<http.Response> post(String path,
      {Object? body, Map<String, String>? headers}) async {
    await start();
    return http.post(uri(path), body: body, headers: headers);
  }

  Future<http.Response> send(
    String method,
    String path, {
    Object? body,
    Map<String, String>? headers,
  }) async {
    await start();
    final request = http.Request(method, uri(path));
    if (body != null) {
      if (body is String) {
        request.body = body;
      } else if (body is List<int>) {
        request.bodyBytes = body;
      } else if (body is Map<String, String>) {
        request.bodyFields = body;
      } else {
        throw ArgumentError('Unsupported body type: ${body.runtimeType}');
      }
    }
    if (headers != null) {
      request.headers.addAll(headers);
    }
    final streamed = await request.send();
    return http.Response.fromStream(streamed);
  }

  Future<http.StreamedResponse> sendStream(
    String method,
    String path, {
    Stream<List<int>>? body,
    Map<String, String>? headers,
  }) async {
    await start();
    final request = http.StreamedRequest(method, uri(path));
    if (headers != null) {
      request.headers.addAll(headers);
    }
    if (body != null) {
      await for (final chunk in body) {
        request.sink.add(chunk);
      }
    }
    await request.sink.close();
    return request.send();
  }

  Future<http.StreamedResponse> sendMultipart(http.MultipartRequest request) {
    return start().then((_) => request.send());
  }

  /// Closes the server and underlying container.
  Future<void> dispose() async {
    final server = _server;
    if (server != null) {
      try {
        await app.close();
      } catch (_) {}
      try {
        await server.close(force: true);
      } catch (_) {}
      await app.waitUntilClosed(server);
      _server = null;
    } else {
      await app.onDispose();
    }
  }
}

-------- [ Separator ] ------

File Name: test/integration/server_lifecycle_test.dart
Size: 1.81 KB
Code:
import 'dart:async';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Server lifecycle', () {
    TestServerHarness? harness;

    tearDown(() => harness?.dispose());

    test('waits for in-flight requests on close', () async {
      final app = DartExpress(
        requestTimeout: const Duration(seconds: 2),
        shutdownTimeout: const Duration(seconds: 2),
      );
      harness = TestServerHarness(app: app);

      final completer = Completer<void>();
      harness!.app.get('/slow', (req, res) async {
        await completer.future;
        res.text('done');
      });

      final responseFuture = harness!.get('/slow');
      await Future.delayed(const Duration(milliseconds: 50));

      final closeFuture = harness!.app.close();

      completer.complete();

      final response = await responseFuture;
      await closeFuture;

      expect(response.statusCode, 200);
    });

    test('rejects new requests once shutdown starts', () async {
      final app = DartExpress(shutdownTimeout: const Duration(seconds: 1));
      harness = TestServerHarness(app: app);
      await harness!.start();

      final slowCompleter = Completer<void>();
      harness!.app.get('/slow', (req, res) async {
        await slowCompleter.future;
        res.text('slow');
      });
      harness!.app.get('/ok', (req, res) => res.text('ok'));

      final slowFuture = harness!.get('/slow');
      final shuttingDown = harness!.app.close();
      await Future.delayed(const Duration(milliseconds: 25));
      final response = await harness!.get('/ok');

      expect(response.statusCode, 503);
      expect(response.body, contains('shutting down'));

      slowCompleter.complete();
      await slowFuture;
      await shuttingDown;
    });
  });
}

-------- [ Separator ] ------

File Name: test/performance/concurrency_test.dart
Size: 1.12 KB
Code:
import 'dart:async';

import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Concurrency', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness.dispose());

    test('handles many concurrent requests without head-of-line blocking',
        () async {
      final active = <int>[];
      var inFlight = 0;

      harness.app.get('/work', (req, res) async {
        inFlight++;
        active.add(inFlight);
        await Future.delayed(const Duration(milliseconds: 40));
        inFlight--;
        res.text('ok');
      });

      final requests =
          List.generate(40, (_) => harness.get('/work')); // 40 concurrent

      final stopwatch = Stopwatch()..start();
      final responses = await Future.wait(requests);
      stopwatch.stop();

      for (final response in responses) {
        expect(response.statusCode, 200);
      }

      expect(active.any((c) => c > 1), isTrue);
      // Sequential would be ~1600ms; allow generous headroom.
      expect(stopwatch.elapsedMilliseconds, lessThan(1200));
    });
  });
}

-------- [ Separator ] ------

File Name: test/security/security_test.dart
Size: 2.24 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Security & robustness', () {
    TestServerHarness? harness;

    tearDown(() => harness?.dispose());

    test('times out hanging requests with 408', () async {
      final app = DartExpress(requestTimeout: const Duration(milliseconds: 75));
      harness = TestServerHarness(app: app);

      harness!.app.get('/hang', (req, res) async {
        await Completer<void>().future;
      });

      final response = await harness!.get('/hang');

      expect(response.statusCode, HttpStatus.requestTimeout);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], contains('Request Timeout'));
    });

    test('recovers after rejecting oversized payloads', () async {
      final app = DartExpress(maxBodySize: 512);
      harness = TestServerHarness(app: app);

      harness!.app
        ..post('/upload', (req, res) async {
          await req.body; // triggers size enforcement
          res.text('ok');
        })
        ..get('/health', (req, res) => res.text('ok'));

      final largeBody = List.filled(2048, 65);
      final rejection = await harness!.post(
        '/upload',
        body: largeBody,
        headers: {HttpHeaders.contentTypeHeader: 'application/octet-stream'},
      );
      final health = await harness!.get('/health');

      expect(rejection.statusCode, HttpStatus.requestEntityTooLarge);
      expect(jsonDecode(rejection.body), isA<Map>());
      expect(health.statusCode, HttpStatus.ok);
      expect(health.body, 'ok');
    });

    test('uses fallback error handler when custom handler fails', () async {
      harness = TestServerHarness();

      harness!.app.setErrorHandler((error, req, res) {
        throw StateError('broken handler');
      });

      harness!.app.get('/boom', (req, res) => throw Exception('boom'));

      final response = await harness!.get('/boom');

      expect(response.statusCode, HttpStatus.internalServerError);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], 'Internal Server Error');
    });
  });
}

-------- [ Separator ] ------

File Name: test/test_12052025_1764904625.txt
Size: 27.06 KB
Code:
Project Overview
===============

Project Statistics:
Total Files: 8
Total Size: 25.59 KB

File Types:
  .dart: 8 files

Detected Technologies:

Folder Structure (Tree)
=====================
Legend: ✓ = Included in output, ✗ = Excluded from output

├── dart_express_test.dart (6.25 KB) ✓
├── helpers/
│   └── test_server_harness.dart (3.06 KB) ✓
├── integration/
│   └── server_lifecycle_test.dart (1.81 KB) ✓
├── performance/
│   └── concurrency_test.dart (1.16 KB) ✓
├── security/
│   └── security_test.dart (2.24 KB) ✓
└── unit/
    ├── middleware_test.dart (2.95 KB) ✓
    ├── request_test.dart (6.18 KB) ✓
    └── router_test.dart (1.94 KB) ✓

==============

File Name: dart_express_test.dart
Size: 6.25 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

void main() {
  group('Application', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());

    tearDown(() async => harness.dispose());

    test('GET / returns 200 with correct body', () async {
      harness.app
          .get('/', (Request req, Response res) => res.text('Hello World!'));

      final response = await harness.get('/');

      expect(response.statusCode, 200);
      expect(response.body, 'Hello World!');
      expect(
          response.headers['set-cookie'], contains(Request.sessionCookieName));
    });

    test('POST / returns 201 with JSON response', () async {
      harness.app.post(
        '/',
        (Request req, Response res) =>
            res.json({'success': true}, statusCode: 201),
      );

      final response = await harness.post('/');

      expect(response.statusCode, 201);
      expect(response.headers['content-type'], 'application/json');
      expect(response.body, '{"success":true}');
    });

    test('Unknown route returns 404 with JSON payload', () async {
      final response = await harness.get('/not_found');

      expect(response.statusCode, 404);
      expect(response.headers['content-type'], 'application/json');
    });
    test('Reuses existing session cookie when provided', () async {
      final cookieHeader = '${Request.sessionCookieName}=existing-session';

      harness.app.get('/', (req, res) => res.text('OK'));

      final response = await harness.get(
        '/',
        headers: {HttpHeaders.cookieHeader: cookieHeader},
      );

      expect(response.statusCode, 200);
      // No duplicate cookie should be issued when already provided
      expect(response.headers['set-cookie'], isNull);
    });
  });

  group('Middleware', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Runs middleware in order', () async {
      final order = <int>[];

      harness.app.use((req, res, next) {
        order.add(1);
        return next();
      });

      harness.app.use((req, res, next) {
        order.add(2);
        return next();
      });

      harness.app.get('/middleware', (req, res) {
        order.add(3);
        res.text('OK');
      });

      final response = await harness.get('/middleware');

      expect(response.statusCode, 200);
      expect(order, [1, 2, 3]);
    });

    test('Middleware can modify response', () async {
      harness.app.use((req, res, next) {
        res.headers['X-Custom-Header'] = '123';
        return next();
      });

      harness.app.get('/header', (req, res) => res.text('OK'));

      final response = await harness.get('/header');

      expect(response.statusCode, 200);
      expect(response.headers['x-custom-header'], '123');
    });
  });

  group('Error Handling', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Unhandled error returns 500', () async {
      harness.app.get('/error', (req, res) => throw Exception('Test Error'));

      final response = await harness.get('/error');

      expect(response.statusCode, 500);
      expect(response.headers['content-type'], 'application/json');
    });
  });

  group('Route Parameters', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Parses route parameters', () async {
      harness.app.get('/users/:id', (req, res) {
        res.text('User ID: ${req.params['id']}');
      });

      final response = await harness.get('/users/123');

      expect(response.statusCode, 200);
      expect(response.body, 'User ID: 123');
    });
  });

  group('Isolated Container', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() async => harness.dispose());

    test('Routes and middleware execute in isolated scope', () async {
      final isolated = IsolatedContainer(prefix: '/island');
      isolated.use((req, res, next) {
        res.setHeader('X-Isolated', 'true');
        return next();
      });
      isolated.get('/', (req, res) => res.text('Isolated Root'));

      isolated.mount(harness.app);

      final response = await harness.get('/island');

      expect(response.statusCode, 200);
      expect(response.body, 'Isolated Root');
      expect(response.headers['x-isolated'], 'true');
    });

    test('Uses independent dependency injection scope', () async {
      final isolated = IsolatedContainer(prefix: '/island');

      harness.app.inject<Dependency>(Dependency('parent'));
      isolated.inject<Dependency>(Dependency('isolated'));

      isolated.get('/value', (req, res) {
        final dep = req.container.get<Dependency>();
        res.json({'value': dep.id});
      });

      isolated.mount(harness.app);

      final response = await harness.get('/island/value');

      expect(response.statusCode, 200);
      expect(response.body, '{"value":"isolated"}');

      final parentResponse = await harness.get('/missing');
      expect(parentResponse.statusCode, 404);
    });
  });
}

class TestServerHarness {
  final DartExpress app = DartExpress();
  HttpServer? _server;

  Future<http.Response> get(String path, {Map<String, String>? headers}) async {
    await _ensureServer();
    return http.get(_uri(path), headers: headers);
  }

  Future<http.Response> post(String path,
      {Object? body, Map<String, String>? headers}) async {
    await _ensureServer();
    return http.post(_uri(path), body: body, headers: headers);
  }

  Future<void> dispose() async {
    if (_server != null) {
      await _server!.close(force: true);
      await app.waitUntilClosed(_server!);
      _server = null;
    } else {
      await app.onDispose();
    }
  }

  Future<void> _ensureServer() async {
    if (_server != null) {
      return;
    }

    _server = await app.listen(0, address: InternetAddress.loopbackIPv4);
  }

  Uri _uri(String path) {
    final normalized = path.startsWith('/') ? path : '/$path';
    return Uri.parse('http://localhost:${_server!.port}$normalized');
  }
}

class Dependency {
  Dependency(this.id);
  final String id;
}

-------- [ Separator ] ------

File Name: helpers/test_server_harness.dart
Size: 3.06 KB
Code:
import 'dart:async';
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;

/// Lightweight harness that spins up a [DartExpress] instance on a random
/// ephemeral port and exposes helpers for common request patterns used in
/// tests.
class TestServerHarness {
  TestServerHarness({DartExpress? app, InternetAddress? address})
      : app = app ?? DartExpress(),
        address = address ?? InternetAddress.loopbackIPv4;

  final DartExpress app;
  final InternetAddress address;
  HttpServer? _server;
  int? _boundPort;

  int get port => _boundPort ?? _server?.port ?? 0;

  /// Starts the underlying [HttpServer] if not already running.
  Future<void> start() async {
    if (_server != null) return;
    _server = await app.listen(0, address: address);
    _boundPort = _server?.port;
  }

  /// Resolved absolute [Uri] for the given [path].
  Uri uri(String path) {
    final normalized = path.startsWith('/') ? path : '/$path';
    return Uri.parse('http://${address.address}:${port}$normalized');
  }

  Future<http.Response> get(String path,
      {Map<String, String>? headers}) async {
    await start();
    return http.get(uri(path), headers: headers);
  }

  Future<http.Response> post(String path,
      {Object? body, Map<String, String>? headers}) async {
    await start();
    return http.post(uri(path), body: body, headers: headers);
  }

  Future<http.Response> send(
    String method,
    String path, {
    Object? body,
    Map<String, String>? headers,
  }) async {
    await start();
    final request = http.Request(method, uri(path));
    if (body != null) {
      if (body is String) {
        request.body = body;
      } else if (body is List<int>) {
        request.bodyBytes = body;
      } else if (body is Map<String, String>) {
        request.bodyFields = body;
      } else {
        throw ArgumentError('Unsupported body type: ${body.runtimeType}');
      }
    }
    if (headers != null) {
      request.headers.addAll(headers);
    }
    final streamed = await request.send();
    return http.Response.fromStream(streamed);
  }

  Future<http.StreamedResponse> sendStream(
    String method,
    String path, {
    Stream<List<int>>? body,
    Map<String, String>? headers,
  }) async {
    await start();
    final request = http.StreamedRequest(method, uri(path));
    if (headers != null) {
      request.headers.addAll(headers);
    }
    if (body != null) {
      await for (final chunk in body) {
        request.sink.add(chunk);
      }
    }
    await request.sink.close();
    return request.send();
  }

  Future<http.StreamedResponse> sendMultipart(http.MultipartRequest request) {
    return start().then((_) => request.send());
  }

  /// Closes the server and underlying container.
  Future<void> dispose() async {
    final server = _server;
    if (server != null) {
      try {
        await app.close();
      } catch (_) {}
      try {
        await server.close(force: true);
      } catch (_) {}
      await app.waitUntilClosed(server);
      _server = null;
    } else {
      await app.onDispose();
    }
  }
}

-------- [ Separator ] ------

File Name: integration/server_lifecycle_test.dart
Size: 1.81 KB
Code:
import 'dart:async';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Server lifecycle', () {
    TestServerHarness? harness;

    tearDown(() => harness?.dispose());

    test('waits for in-flight requests on close', () async {
      final app = DartExpress(
        requestTimeout: const Duration(seconds: 2),
        shutdownTimeout: const Duration(seconds: 2),
      );
      harness = TestServerHarness(app: app);

      final completer = Completer<void>();
      harness!.app.get('/slow', (req, res) async {
        await completer.future;
        res.text('done');
      });

      final responseFuture = harness!.get('/slow');
      await Future.delayed(const Duration(milliseconds: 50));

      final closeFuture = harness!.app.close();

      completer.complete();

      final response = await responseFuture;
      await closeFuture;

      expect(response.statusCode, 200);
    });

    test('rejects new requests once shutdown starts', () async {
      final app = DartExpress(shutdownTimeout: const Duration(seconds: 1));
      harness = TestServerHarness(app: app);
      await harness!.start();

      final slowCompleter = Completer<void>();
      harness!.app.get('/slow', (req, res) async {
        await slowCompleter.future;
        res.text('slow');
      });
      harness!.app.get('/ok', (req, res) => res.text('ok'));

      final slowFuture = harness!.get('/slow');
      final shuttingDown = harness!.app.close();
      await Future.delayed(const Duration(milliseconds: 25));
      final response = await harness!.get('/ok');

      expect(response.statusCode, 503);
      expect(response.body, contains('shutting down'));

      slowCompleter.complete();
      await slowFuture;
      await shuttingDown;
    });
  });
}

-------- [ Separator ] ------

File Name: performance/concurrency_test.dart
Size: 1.16 KB
Code:
import 'dart:async';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Concurrency', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness.dispose());

    test('handles many concurrent requests without head-of-line blocking',
        () async {
      final active = <int>[];
      var inFlight = 0;

      harness.app.get('/work', (req, res) async {
        inFlight++;
        active.add(inFlight);
        await Future.delayed(const Duration(milliseconds: 40));
        inFlight--;
        res.text('ok');
      });

      final requests =
          List.generate(40, (_) => harness.get('/work')); // 40 concurrent

      final stopwatch = Stopwatch()..start();
      final responses = await Future.wait(requests);
      stopwatch.stop();

      for (final response in responses) {
        expect(response.statusCode, 200);
      }

      expect(active.any((c) => c > 1), isTrue);
      // Sequential would be ~1600ms; allow generous headroom.
      expect(stopwatch.elapsedMilliseconds, lessThan(1200));
    });
  });
}

-------- [ Separator ] ------

File Name: security/security_test.dart
Size: 2.24 KB
Code:
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Security & robustness', () {
    TestServerHarness? harness;

    tearDown(() => harness?.dispose());

    test('times out hanging requests with 408', () async {
      final app = DartExpress(requestTimeout: const Duration(milliseconds: 75));
      harness = TestServerHarness(app: app);

      harness!.app.get('/hang', (req, res) async {
        await Completer<void>().future;
      });

      final response = await harness!.get('/hang');

      expect(response.statusCode, HttpStatus.requestTimeout);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], contains('Request Timeout'));
    });

    test('recovers after rejecting oversized payloads', () async {
      final app = DartExpress(maxBodySize: 512);
      harness = TestServerHarness(app: app);

      harness!.app
        ..post('/upload', (req, res) async {
          await req.body; // triggers size enforcement
          res.text('ok');
        })
        ..get('/health', (req, res) => res.text('ok'));

      final largeBody = List.filled(2048, 65);
      final rejection = await harness!.post(
        '/upload',
        body: largeBody,
        headers: {HttpHeaders.contentTypeHeader: 'application/octet-stream'},
      );
      final health = await harness!.get('/health');

      expect(rejection.statusCode, HttpStatus.requestEntityTooLarge);
      expect(jsonDecode(rejection.body), isA<Map>());
      expect(health.statusCode, HttpStatus.ok);
      expect(health.body, 'ok');
    });

    test('uses fallback error handler when custom handler fails', () async {
      harness = TestServerHarness();

      harness!.app.setErrorHandler((error, req, res) {
        throw StateError('broken handler');
      });

      harness!.app.get('/boom', (req, res) => throw Exception('boom'));

      final response = await harness!.get('/boom');

      expect(response.statusCode, HttpStatus.internalServerError);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], 'Internal Server Error');
    });
  });
}

-------- [ Separator ] ------

File Name: unit/middleware_test.dart
Size: 2.95 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Middleware pipeline', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness.dispose());

    test('executes global middleware before route middleware', () async {
      final execution = <String>[];

      harness.app.use((req, res, next) async {
        execution.add('global');
        await next();
      });

      harness.app.get(
        '/ordered',
        (req, res) {
          execution.add('handler');
          res.text('done');
        },
        middleware: [
          (req, res, next) async {
            execution.add('route');
            await next();
          },
        ],
      );

      final response = await harness.get('/ordered');

      expect(response.statusCode, 200);
      expect(execution, ['global', 'route', 'handler']);
    });

    test('CORS middleware allows configured origins', () async {
      harness.app.use(
        harness.app.cors(
          allowedOrigins: const ['https://example.com'],
          allowedMethods: const ['GET', 'OPTIONS'],
          allowCredentials: true,
        ),
      );

      harness.app.options('/cors', (req, res) {});

      final response = await harness.send(
        'OPTIONS',
        '/cors',
        headers: {
          'Origin': 'https://example.com',
          'Access-Control-Request-Method': 'GET',
        },
      );

      expect(response.statusCode, HttpStatus.noContent);
      expect(response.headers['access-control-allow-origin'],
          equals('https://example.com'));
      expect(response.headers['access-control-allow-credentials'], 'true');
    });

    test('CORS middleware rejects disallowed origins', () async {
      harness.app.use(
        harness.app.cors(
          allowedOrigins: const ['https://allowed.com'],
        ),
      );
      harness.app.get('/cors', (req, res) => res.text('ok'));

      final response = await harness.get(
        '/cors',
        headers: {'Origin': 'https://blocked.com'},
      );

      expect(response.statusCode, HttpStatus.forbidden);
      expect(response.body, contains('CORS policy'));
    });

    test('rate limiter returns 429 when limit exceeded', () async {
      final store = MemoryRateLimitStore();
      harness.app.use(
        harness.app.rateLimiter(
          maxRequests: 2,
          window: const Duration(seconds: 1),
          store: store,
        ),
      );
      harness.app.get('/limited', (req, res) => res.text('ok'));

      final first = await harness.get('/limited');
      final second = await harness.get('/limited');
      final third = await harness.get('/limited');

      expect(first.statusCode, 200);
      expect(second.statusCode, 200);
      expect(third.statusCode, HttpStatus.tooManyRequests);
      expect(third.body, contains('Rate limit exceeded'));

      store.dispose();
    });
  });
}

-------- [ Separator ] ------

File Name: unit/request_test.dart
Size: 6.18 KB
Code:
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Request parsing', () {
    TestServerHarness? harness;

    setUp(() => harness = TestServerHarness());

    tearDown(() => harness?.dispose());

    test('parses JSON bodies and caches the result', () async {
      harness!.app.post('/json', (req, res) async {
        final first = await req.body;
        final second = await req.body;
        res.json({'first': first, 'sameInstance': identical(first, second)});
      });

      final response = await harness!.post(
        '/json',
        body: '{"message":"hi"}',
        headers: {HttpHeaders.contentTypeHeader: ContentType.json.mimeType},
      );

      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(response.statusCode, 200);
      expect(payload['first'], equals({'message': 'hi'}));
      expect(payload['sameInstance'], isTrue);
    });

    test('parses urlencoded forms', () async {
      harness!.app.post('/form', (req, res) async {
        final body = await req.body as Map<String, String>;
        res.json(body);
      });

      final response = await harness!.post(
        '/form',
        body: 'foo=bar&baz=qux',
        headers: {
          HttpHeaders.contentTypeHeader:
              'application/x-www-form-urlencoded; charset=utf-8'
        },
      );

      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(response.statusCode, 200);
      expect(payload, containsPair('foo', 'bar'));
      expect(payload, containsPair('baz', 'qux'));
    });

    test('returns raw bytes for unknown content type', () async {
      harness!.app.post('/bytes', (req, res) async {
        final body = await req.body as Uint8List;
        res.bytes(body, statusCode: 201);
      });

      final bytes = utf8.encode('raw-data');
      final response = await harness!.post(
        '/bytes',
        body: bytes,
        headers: {HttpHeaders.contentTypeHeader: 'application/octet-stream'},
      );

      expect(response.statusCode, 201);
      expect(response.bodyBytes, bytes);
    });

    test('rejects payload exceeding maxBodySize with 413', () async {
      await harness?.dispose();
      harness = TestServerHarness(
        app: DartExpress(maxBodySize: 256),
      );
      harness!.app.post('/limit', (req, res) async {
        await req.body; // Triggers body read and size enforcement
        res.text('ok');
      });

      final body = List.filled(1024, 65); // 1KB
      final response = await harness!.post(
        '/limit',
        body: body,
        headers: {HttpHeaders.contentTypeHeader: 'application/octet-stream'},
      );

      expect(response.statusCode, 413);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], contains('Payload Too Large'));
    });
  });

  group('Multipart parsing', () {
    TestServerHarness? harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness?.dispose());

    test('merges fields and files into formData', () async {
      await harness!.start();
      harness!.app.post('/upload', (req, res) async {
        final formData = await req.formData;
        res.json({
          'fields': formData.map(
            (key, value) => MapEntry(key, value is String ? value : null),
          ),
          'fileLengths': formData.map((key, value) => MapEntry(
              key,
              value is List
                  ? (value.first as http.MultipartFile).length
                  : null)),
        });
      });

      final request = http.MultipartRequest(
        'POST',
        harness!.uri('/upload'),
      )
        ..fields['name'] = 'demo'
        ..files.add(http.MultipartFile.fromBytes(
          'avatar',
          List.filled(10, 1),
          filename: 'avatar.png',
        ));

      final streamed = await harness!.sendMultipart(request);
      final response = await http.Response.fromStream(streamed);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;

      expect(response.statusCode, 200);
      expect(payload['fields']['name'], 'demo');
      expect(payload['fileLengths']['avatar'], 10);
    });

    test('enforces maxFileSize during multipart parsing', () async {
      await harness?.dispose();
      harness = TestServerHarness(
        app: DartExpress(maxFileSize: 64 * 2, maxBodySize: 1024),
      );

      await harness!.start();
      harness!.app.post('/files', (req, res) async {
        await req.files;
        res.text('ok');
      });

      final request = http.MultipartRequest(
        'POST',
        harness!.uri('/files'),
      )..files.add(http.MultipartFile.fromBytes(
          'file',
          List.filled(200, 1), // Exceeds maxFileSize
          filename: 'big.bin',
        ));

      final response =
          await http.Response.fromStream(await harness!.sendMultipart(request));

      expect(response.statusCode, 413);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], contains('File too large'));
    });
  });

  group('Session cookies', () {
    TestServerHarness? harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness?.dispose());

    test('sets HttpOnly session cookie when missing', () async {
      harness!.app.get('/session', (req, res) => res.text('OK'));

      final response = await harness!.get('/session');

      final cookie = response.headers[HttpHeaders.setCookieHeader];
      expect(response.statusCode, 200);
      expect(cookie, contains(Request.sessionCookieName));
      expect(cookie, contains('HttpOnly'));
    });

    test('reuses provided session cookie', () async {
      final cookieHeader =
          '${Request.sessionCookieName}=existing-session; Path=/';
      harness!.app.get('/session', (req, res) => res.text('OK'));

      final response = await harness!.get(
        '/session',
        headers: {HttpHeaders.cookieHeader: cookieHeader},
      );

      expect(response.statusCode, 200);
      expect(response.headers[HttpHeaders.setCookieHeader], isNull);
    });
  });
}

-------- [ Separator ] ------

File Name: unit/router_test.dart
Size: 1.94 KB
Code:
import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

void main() {
  group('RadixRouter matching', () {
    late RadixRouter router;

    setUp(() => router = RadixRouter());

    test('matches static routes first', () {
      final handler = (Request _, Response __) {};
      router.addRoute('GET', '/users/list', handler);
      router.addRoute('GET', '/users/:id', (req, res) {});

      final match = router.findRoute('GET', '/users/list');
      expect(match, isNotNull);
      expect(match!.handler, same(handler));
    });

    test('extracts regex constrained parameters', () {
      router.addRoute('GET', '/users/:id(\\d+)', (req, res) {});
      final match = router.findRoute('GET', '/users/42');

      expect(match, isNotNull);
      expect(match!.pathParams['id'], '42');
    });

    test('skips non-matching regex segments', () {
      router.addRoute('GET', '/users/:id(\\d+)', (req, res) {});
      final match = router.findRoute('GET', '/users/abc');

      expect(match, isNull);
    });

    test('supports wildcard parameters', () {
      router.addRoute('GET', '/assets/:file', (req, res) {});
      final match = router.findRoute('GET', '/assets/logo.png');

      expect(match, isNotNull);
      expect(match!.pathParams['file'], 'logo.png');
    });

    test('throws on conflicting handlers', () {
      router.addRoute('GET', '/conflict', (req, res) {});
      expect(
        () => router.addRoute('GET', '/conflict', (req, res) {}),
        throwsA(isA<RouteConflictError>()),
      );
    });

    test('delegates to isolated routers at prefixes', () {
      final isolated = RadixRouter();
      final isolatedHandler = (Request _, Response __) {};
      isolated.addRoute('GET', '/health', isolatedHandler);

      router.addIsolatedRouter('/api', isolated);

      final match = router.findRoute('GET', '/api/health');
      expect(match, isNotNull);
      expect(match!.handler, same(isolatedHandler));
    });
  });
}

-------- [ Separator ] ------

-------- [ Separator ] ------

File Name: test/unit/config_test.dart
Size: 519 B
Code:
import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

void main() {
  group('Configuration validation', () {
    test('throws on invalid body size', () {
      expect(
        () => DartExpress(maxBodySize: 0),
        throwsA(isA<ArgumentError>()),
      );
    });

    test('warns when file size exceeds body size', () {
      // Should not throw, just warn
      expect(
        () => DartExpress(maxBodySize: 1024, maxFileSize: 2048),
        returnsNormally,
      );
    });
  });
}

-------- [ Separator ] ------

File Name: test/unit/middleware_test.dart
Size: 3.15 KB
Code:
import 'dart:io';

import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Middleware pipeline', () {
    late TestServerHarness harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness.dispose());

    test('executes global middleware before route middleware', () async {
      final execution = <String>[];

      harness.app.use((req, res, next) async {
        execution.add('global');
        await next();
      });

      harness.app.get(
        '/ordered',
        (req, res) {
          execution.add('handler');
          res.text('done');
        },
        middleware: [
          (req, res, next) async {
            execution.add('route');
            await next();
          },
        ],
      );

      final response = await harness.get('/ordered');

      expect(response.statusCode, 200);
      expect(execution, ['global', 'route', 'handler']);
    });

    test('CORS middleware allows configured origins', () async {
      harness.app.use(
        harness.app.cors(
          allowedOrigins: const ['https://example.com'],
          allowedMethods: const ['GET', 'OPTIONS'],
          allowCredentials: true,
        ),
      );

      harness.app.options('/cors', (req, res) {});

      final response = await harness.send(
        'OPTIONS',
        '/cors',
        headers: {
          'Origin': 'https://example.com',
          'Access-Control-Request-Method': 'GET',
        },
      );

      expect(response.statusCode, HttpStatus.noContent);
      expect(response.headers['access-control-allow-origin'],
          equals('https://example.com'));
      expect(response.headers['access-control-allow-credentials'], 'true');
    });

    test('CORS middleware rejects disallowed origins', () async {
      harness.app.use(
        harness.app.cors(
          allowedOrigins: const ['https://allowed.com'],
        ),
      );
      harness.app.get('/cors', (req, res) => res.text('ok'));

      final response = await harness.get(
        '/cors',
        headers: {'Origin': 'https://blocked.com'},
      );

      expect(response.statusCode, HttpStatus.forbidden);
      expect(response.body, contains('CORS policy'));
    });

    test('CORS throws when allowCredentials with wildcard origins', () {
      expect(
        () => harness.app.cors(allowCredentials: true),
        throwsA(isA<ArgumentError>()),
      );
    });

    test('rate limiter returns 429 when limit exceeded', () async {
      final store = MemoryRateLimitStore();
      harness.app.use(
        harness.app.rateLimiter(
          maxRequests: 2,
          window: const Duration(seconds: 1),
          store: store,
        ),
      );
      harness.app.get('/limited', (req, res) => res.text('ok'));

      final first = await harness.get('/limited');
      final second = await harness.get('/limited');
      final third = await harness.get('/limited');

      expect(first.statusCode, 200);
      expect(second.statusCode, 200);
      expect(third.statusCode, HttpStatus.tooManyRequests);
      expect(third.body, contains('Rate limit exceeded'));

      store.dispose();
    });
  });
}

-------- [ Separator ] ------

File Name: test/unit/request_test.dart
Size: 6.50 KB
Code:
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:dart_express/dart_express.dart';
import 'package:http/http.dart' as http;
import 'package:test/test.dart';

import '../helpers/test_server_harness.dart';

void main() {
  group('Request parsing', () {
    TestServerHarness? harness;

    setUp(() => harness = TestServerHarness());

    tearDown(() => harness?.dispose());

    test('parses JSON bodies and caches the result', () async {
      harness!.app.post('/json', (req, res) async {
        final first = await req.body;
        final second = await req.body;
        res.json({'first': first, 'sameInstance': identical(first, second)});
      });

      final response = await harness!.post(
        '/json',
        body: '{"message":"hi"}',
        headers: {HttpHeaders.contentTypeHeader: ContentType.json.mimeType},
      );

      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(response.statusCode, 200);
      expect(payload['first'], equals({'message': 'hi'}));
      expect(payload['sameInstance'], isTrue);
    });

    test('parses urlencoded forms', () async {
      harness!.app.post('/form', (req, res) async {
        final body = await req.body as Map<String, String>;
        res.json(body);
      });

      final response = await harness!.post(
        '/form',
        body: 'foo=bar&baz=qux',
        headers: {
          HttpHeaders.contentTypeHeader:
              'application/x-www-form-urlencoded; charset=utf-8'
        },
      );

      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(response.statusCode, 200);
      expect(payload, containsPair('foo', 'bar'));
      expect(payload, containsPair('baz', 'qux'));
    });

    test('returns raw bytes for unknown content type', () async {
      harness!.app.post('/bytes', (req, res) async {
        final body = await req.body as Uint8List;
        res.bytes(body, statusCode: 201);
      });

      final bytes = utf8.encode('raw-data');
      final response = await harness!.post(
        '/bytes',
        body: bytes,
        headers: {HttpHeaders.contentTypeHeader: 'application/octet-stream'},
      );

      expect(response.statusCode, 201);
      expect(response.bodyBytes, bytes);
    });

    test('rejects payload exceeding maxBodySize with 413', () async {
      await harness?.dispose();
      harness = TestServerHarness(
        app: DartExpress(maxBodySize: 256),
      );
      harness!.app.post('/limit', (req, res) async {
        await req.body; // Triggers body read and size enforcement
        res.text('ok');
      });

      final body = List.filled(1024, 65); // 1KB
      final response = await harness!.post(
        '/limit',
        body: body,
        headers: {HttpHeaders.contentTypeHeader: 'application/octet-stream'},
      );

      expect(response.statusCode, 413);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], contains('Payload Too Large'));
    });
  });

  group('Multipart parsing', () {
    TestServerHarness? harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness?.dispose());

    test('merges fields and files into formData', () async {
      await harness!.start();
      harness!.app.post('/upload', (req, res) async {
        final formData = await req.formData;
        res.json({
          'fields': formData.map(
            (key, value) => MapEntry(key, value is String ? value : null),
          ),
          'fileLengths': formData.map((key, value) => MapEntry(
              key,
              value is List
                  ? (value.first as http.MultipartFile).length
                  : null)),
        });
      });

      final request = http.MultipartRequest(
        'POST',
        harness!.uri('/upload'),
      )
        ..fields['name'] = 'demo'
        ..files.add(http.MultipartFile.fromBytes(
          'avatar',
          List.filled(10, 1),
          filename: 'avatar.png',
        ));

      final streamed = await harness!.sendMultipart(request);
      final response = await http.Response.fromStream(streamed);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;

      expect(response.statusCode, 200);
      expect(payload['fields']['name'], 'demo');
      expect(payload['fileLengths']['avatar'], 10);
    });

    test('enforces maxFileSize during multipart parsing', () async {
      await harness?.dispose();
      harness = TestServerHarness(
        app: DartExpress(maxFileSize: 64 * 2, maxBodySize: 1024),
      );

      await harness!.start();
      harness!.app.post('/files', (req, res) async {
        await req.files;
        res.text('ok');
      });

      final request = http.MultipartRequest(
        'POST',
        harness!.uri('/files'),
      )..files.add(http.MultipartFile.fromBytes(
          'file',
          List.filled(200, 1), // Exceeds maxFileSize
          filename: 'big.bin',
        ));

      final response =
          await http.Response.fromStream(await harness!.sendMultipart(request));

      expect(response.statusCode, 413);
      final payload = jsonDecode(response.body) as Map<String, dynamic>;
      expect(payload['error'], contains('File too large'));
    });
  });

  group('Session cookies', () {
    TestServerHarness? harness;

    setUp(() => harness = TestServerHarness());
    tearDown(() => harness?.dispose());

    test('sets HttpOnly session cookie when missing', () async {
      harness!.app.get('/session', (req, res) => res.text('OK'));

      final response = await harness!.get('/session');

      final cookie = response.headers[HttpHeaders.setCookieHeader];
      expect(response.statusCode, 200);
      expect(cookie, contains(Request.sessionCookieName));
      expect(cookie, contains('HttpOnly'));
    });

    test('reuses provided session cookie', () async {
      final cookieHeader =
          '${Request.sessionCookieName}=existing-session; Path=/';
      harness!.app.get('/session', (req, res) => res.text('OK'));

      final response = await harness!.get(
        '/session',
        headers: {HttpHeaders.cookieHeader: cookieHeader},
      );

      expect(response.statusCode, 200);
      expect(response.headers[HttpHeaders.setCookieHeader], isNull);
    });

    test('propagates request id to response header', () async {
      harness!.app.get('/trace', (req, res) => res.text('traced'));

      final response = await harness!.get(
        '/trace',
        headers: {'x-request-id': 'abc-123'},
      );

      expect(response.headers['x-request-id'], equals('abc-123'));
    });
  });
}

-------- [ Separator ] ------

File Name: test/unit/router_test.dart
Size: 1.94 KB
Code:
import 'package:dart_express/dart_express.dart';
import 'package:test/test.dart';

void main() {
  group('RadixRouter matching', () {
    late RadixRouter router;

    setUp(() => router = RadixRouter());

    test('matches static routes first', () {
      final handler = (Request _, Response __) {};
      router.addRoute('GET', '/users/list', handler);
      router.addRoute('GET', '/users/:id', (req, res) {});

      final match = router.findRoute('GET', '/users/list');
      expect(match, isNotNull);
      expect(match!.handler, same(handler));
    });

    test('extracts regex constrained parameters', () {
      router.addRoute('GET', '/users/:id(\\d+)', (req, res) {});
      final match = router.findRoute('GET', '/users/42');

      expect(match, isNotNull);
      expect(match!.pathParams['id'], '42');
    });

    test('skips non-matching regex segments', () {
      router.addRoute('GET', '/users/:id(\\d+)', (req, res) {});
      final match = router.findRoute('GET', '/users/abc');

      expect(match, isNull);
    });

    test('supports wildcard parameters', () {
      router.addRoute('GET', '/assets/:file', (req, res) {});
      final match = router.findRoute('GET', '/assets/logo.png');

      expect(match, isNotNull);
      expect(match!.pathParams['file'], 'logo.png');
    });

    test('throws on conflicting handlers', () {
      router.addRoute('GET', '/conflict', (req, res) {});
      expect(
        () => router.addRoute('GET', '/conflict', (req, res) {}),
        throwsA(isA<RouteConflictError>()),
      );
    });

    test('delegates to isolated routers at prefixes', () {
      final isolated = RadixRouter();
      final isolatedHandler = (Request _, Response __) {};
      isolated.addRoute('GET', '/health', isolatedHandler);

      router.addIsolatedRouter('/api', isolated);

      final match = router.findRoute('GET', '/api/health');
      expect(match, isNotNull);
      expect(match!.handler, same(isolatedHandler));
    });
  });
}

-------- [ Separator ] ------

File Name: tool/benchmark.dart
Size: 845 B
Code:
import 'dart:async';
import 'dart:io';

import 'package:dart_express/dart_express.dart';

Future<void> main(List<String> args) async {
  final app = DartExpress();

  app.get('/bench', (req, res) {
    res.json({
      'status': 'ok',
      'timestamp': DateTime.now().millisecondsSinceEpoch,
      'requestId': req.requestId,
    });
  });

  app.enableHealthCheck();

  await app.listen(8080);

  stdout.writeln('''
Benchmark endpoints:
  - GET /bench   (JSON)
  - GET /health  (health check)

Run load with:
  wrk -t4 -c100 -d30s http://localhost:8080/bench
or:
  ab -n 10000 -c 100 http://localhost:8080/bench
''');

  ProcessSignal.sigint.watch().listen((_) async {
    stdout.writeln('\nShutting down gracefully...');
    await app.close();
    exit(0);
  });

  // Keep the process alive until SIGINT.
  await Completer<void>().future;
}

-------- [ Separator ] ------

File Name: tool/serve_multi.dart
Size: 913 B
Code:
import 'dart:io';
import 'dart:isolate';

import 'package:dart_express/dart_express.dart';

Future<void> main(List<String> args) async {
  final workers =
      args.isNotEmpty ? int.parse(args.first) : Platform.numberOfProcessors;
  final port = args.length > 1 ? int.parse(args[1]) : 8080;

  // Spawn worker isolates (leave one in the main isolate)
  for (var i = 0; i < workers - 1; i++) {
    await Isolate.spawn(_startWorker, [port]);
  }
  await _startWorker([port]); // main worker
}

Future<void> _startWorker(List<dynamic> params) async {
  final port = params[0] as int;
  final app = DartExpress();

  app.get('/bench', (req, res) {
    res.json({'status': 'ok', 'requestId': req.requestId});
  });
  app.enableHealthCheck();
  print('address: ${InternetAddress.loopbackIPv4}');
  print('port: $port');
  await app.listen(
    port,
    address: InternetAddress.loopbackIPv4,
    shared: true,
  );
}

-------- [ Separator ] ------

File Name: tool/serve_multi.k6.js
Size: 1.59 KB
Code:
import http from 'k6/http';
import { check, sleep } from 'k6';

const BASE_URL = __ENV.BASE_URL || 'http://127.0.0.1:8080';

export const options = {
  scenarios: {
    bench: {
      executor: 'ramping-vus',
      exec: 'bench',
      startVUs: 0,
      stages: [
        { duration: '10s', target: 10 },
        { duration: '20s', target: 50 },
        { duration: '20s', target: 100 },
        { duration: '10s', target: 0 },
      ],
      gracefulRampDown: '5s',
    },
    health: {
      executor: 'constant-vus',
      exec: 'healthCheck',
      vus: 1,
      duration: '1m',
      startTime: '0s',
      tags: { scenario: 'health' },
    },
  },
  thresholds: {
    http_req_failed: ['rate<0.01'],
    http_req_duration: ['p(95)<50'],
    'checks{endpoint:bench}': ['rate>0.99'],
  },
};

export function setup() {
  const res = http.get(`${BASE_URL}/health`, {
    tags: { endpoint: 'health' },
  });
  check(res, {
    'health 200': (r) => r.status === 200,
    'health status ok': (r) => r.status === 200 && r.json('status') === 'ok',
  });
}

export function bench() {
  const res = http.get(`${BASE_URL}/bench`, {
    tags: { endpoint: 'bench' },
  });

  check(res, {
    'bench 200': (r) => r.status === 200,
    'bench status ok': (r) => r.json('status') === 'ok',
    'bench has requestId': (r) => r.json('requestId') !== undefined,
  });

  sleep(0.1);
}

export function healthCheck() {
  const res = http.get(`${BASE_URL}/health`, {
    tags: { endpoint: 'health' },
  });
  check(res, {
    'health 200': (r) => r.status === 200,
    'health status ok': (r) => r.json('status') === 'ok',
  });
  sleep(1);
}

-------- [ Separator ] ------
